//! # Tauri application configuration and generation

use proc_macro::TokenStream;

/// A macro that generates the contents of a [Tauri (version 1)
/// ](https://tauri.app/v1/guides) application's `main.rs`.
///
/// It uses [`vicocomo::Config`
/// ](../vicocomo/http/server/struct.HttpServerIf.html#config-macro-input-syntax)
/// to produce
/// - a `main()` function,
/// - a Tauri command `request()` (see below), and
/// - glue code to make the `request()` call the controllers defined in the
///   `vicocomo::Config` [documentation.
///   ](../vicocomo/http/server/struct.HttpServerIf.html#controller-path-and-handling-method)
///
/// ### How to use `request()` in Javascript
///
/// The Rust declaration is
/// ```text
/// #[tauri::command]
/// fn request(
///     app: tauri::AppHandle,
///     storage: tauri::State<_>,
///     method: &str,
///     url: &str,
///     body: &str,
/// ) -> (u32, String) {
///     // glue code calling your controllers
/// }
/// ```
/// The parameters `app` and `storage` are supplied by Tauri and should not be
/// sent from Javascript. The command is invoked in Javascript as
/// ```text
/// let response = invoke(
///   'request',
///   {
///     // an HTTP method
///     method: 'get',
///     // If the host is not a loopback the link is opened in a new window
///     url: 'http://localhost/local/path?p1=foo&p2=bar',
///     // parameters in the body should be URL encoded
///     body: 'p3=baz&p4=qux',
///   }
/// );
/// let status = response[0];   // an integer
/// let content = response[1];  // a string
/// ```
/// The idea is to mimic an HTTP request.
///
/// The response is a Javascript array with two elements, the HTTP status code
/// and the response body. No headers!
///
/// If the `url` is not [`config`
/// ](../vicocomo/http/server/struct.HttpServerIf.html#level-1-route-and-not-found)ured
/// to call a controller, a 404 HTTP error message will be returned.
///
/// The body is a string, so if you wish to respond with a JSON object using
/// [`resp_ok()`
/// ](../vicocomo/http/server/struct.HttpServerIf.html#method.resp_ok),
/// you should use [`serde_json::to_string()`
/// ](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html) to
/// serialize it, and your Javascript should [`JSON.parse()`
/// ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)
/// the response body.
///
/// `request()` concats the `body` parameters to those in the `url`, so it
/// does not matter where you put the parameters.
///
/// ### External URLs
///
/// If the host part of the `url` is present and is not a loopback address or
/// `localhost`, `request()` neither calls a controller nor returns an error.
/// Instead it tries to open a web browser and point it to the URL. The
/// returned Javascript array is `[0, ""]`.
///
/// ### Simple glue Javascript
///
/// The code below, if loaded by hour HTML pages, will turn a server-based
/// HTML application to a Tauri desktop as long as you do not use Javascript
/// to do requests. It does so by capturing link clicks and form submits and
/// invoke [`request()`](#how-to-call-request-in-javascript).
///
/// Unfortunately this simple idea does not work well for forms with
/// `enctype="multipart/form-data"`, e.g. for file upload. But you want to
/// do the file selection and reading from Rust anyway. To achieve this, the
/// code generated by `config!()` expects the UI to rewrite forms with
/// `enctype="multipart/form-data"` to send the POST url with parameters
/// - `__VICOCOMO__upload_name="`*the file input name*`"` and, if the input
///   has the attribute `multiple`,
/// - __VICOCOMO__upload_multiple`.
/// The javascript below does that. But beware that your controller will not
/// get all information it would get from a browser. Specifically the content
/// types are limited to `text/plain` if the file contents are valid UTF-8. or
/// `application/octet-stream` if they are not.
///
/// If a control in a form has a `change` event handler that submits the form,
/// this will not work. If you remove the event handler and give the control
/// the class `"vicocomo--submit-on-change", the javascript below will have
/// the same effect.
///
/// This Tauri adapter does not support routes declared `upload` as described
/// [here
/// ](../vicocomo/http/server/struct.HttpServerIf.html#level-1-route-and-not_found).
/// Calling [`handle_upload()`
/// ](../vicocomo/http/server/struct.HttpServerIf.html#method.handle_upload)
/// returns an `Error`.
///
/// ```text
/// const { invoke } = window.__TAURI__.tauri
///
/// const invoke_request = (evnt, method, url, body) => {
///   if (evnt) {
///     evnt.preventDefault();
///   }
///   invoke("request", { method: method, url: url, body: body })
///     .then((response) => {
///       if (response[0]) {
///           document.querySelector("html").innerHTML = response[1];
///           capture_links();
///           capture_forms();
///           capture_submit_onchange();
///       }
///     })
/// }
///
/// const capture_links = () => {
///   let links = document.querySelectorAll("a");
///   links.forEach((link) => {
///     link.onclick = (e) => {
///       invoke_request(e, "get", e.target.href, "");
///     }
///   });
/// }
///
/// const send_form = (e, form) => {
///   let bdy = "";
///   let formData = new FormData(form);
///   for (let [name, value] of formData) {
///     console.log(name, value);
///     if (bdy.length > 0) {
///       bdy += "&";
///     }
///     bdy += name + "=" + value;
///   }
///   invoke_request(
///     e,
///     form.method,
///     form.action,
///     bdy,
///   );
/// }
///
/// const capture_forms = () => {
///   let forms = document.querySelectorAll("form");
///   forms.forEach((form) => {
///     if (form.getAttribute("enctype") == "multipart/form-data"
///       && form.method.toUpperCase() == "POST"
///     ) {
///       // Hack to prevent the UI to load the file:
///       // - Hide the submit button
///       // - Make the file control send a __VICOCOMO__upload... request
///       // - The file is loaded by vicocomo_tauri::fix_body()
///       for (let ix = 0; ix < form.elements.length; ix++) {
///         let elem = form.elements[ix];
///         switch (elem.getAttribute("type")) {
///           case "submit":
///           case "button":
///             elem.setAttribute("type", "hidden");
///             break;
///           case "file":
///             elem.setAttribute("action", form.action);
///             elem.onclick = (e) => {
///               let bdy = "__VICOCOMO__upload_name=" + e.target.name;
///               if (e.target.getAttribute("multiple") !== null) {
///                 bdy = bdy + "&" + "__VICOCOMO__upload_multiple";
///               }
///               invoke_request(e, "POST", e.target.getAttribute("action"), bdy);
///             }
///             break;
///           default:
///         }
///       }
///     } else {
///       form.onsubmit = (e) => {
///         send_form(e, e.target);
///       }
///     }
///   });
/// }
///
/// const capture_submit_onchange = () => {
///   let submitters = document.querySelectorAll(".vicocomo--submit-on-change");
///   submitters.forEach((submitter) => {
///     submitter.onchange = (e) => {
///       send_form(null, e.target.form);
///     }
///   })
/// }
/// ```
/// ### Adapter specific attributes
///
/// See [`vicocomo::Config`
/// ](../vicocomo/http/server/struct.HttpServerIf.html#level-1-app_config)
/// documentation.
///
/// #### `db_file`
///
/// The value should be a string that is the name of the Sqlite database file.
/// Default `"tauri.sqlite"`.
///
/// #### `template_dir`
///
/// The value should be an array of two strings, the name of a directory
/// containing the templates and the template file extension. This is needed
/// because the template engine is initialized before the Tauri application,
/// and the files cannot be loaded before application initialization.
///
/// This requires the template engine implementation to override
/// [`TemplEng::register_templ_dir()`
/// ](../vicocomo/http/config/trait.TemplEng.html#method.register_templ_dir).
///
/// #### persistent
///
/// The value should be a boolean that determines whether the data stored by
/// [`HttpServerIf::session_set()`
/// ](../vicocomo/http/server/struct.HttpServerIf.html#method.session_set) is
/// [stored in the database
/// ](../vicocomo/http/config/struct.HttpDbSession.html). Default `false`.
///
#[proc_macro]
pub fn config(input: TokenStream) -> TokenStream {
    use proc_macro2::Span;
    use quote::quote;
    use syn::{parse_macro_input, parse_quote, LitStr, Path};
    use vicocomo::{Config, ConfigAttrVal, HttpServerImpl};

    const DB_FILE_DEFAULT: &'static str = "tauri.sqlite";

    let config = parse_macro_input!(input as Config);
    let db_file = config
        .app_config
        .get("db_file")
        .and_then(|val| {
            if let ConfigAttrVal::Str(db_file) = val {
                Some(db_file.clone())
            } else {
                None
            }
        })
        .unwrap_or_else(|| LitStr::new(DB_FILE_DEFAULT, Span::call_site()));
    let persistent = config
        .app_config
        .get("persistent")
        .map(|val| val.get_bool().expect("persistent value should be bool"))
        .unwrap_or(false);
    let build_server = HttpServerImpl::build_expr(
        &config,
        persistent.then(|| parse_quote!(db)),
    );
    let (_, teng_init) = config.plug_ins.get("TemplEng").unwrap();
    let (templ_dir, templ_ext) = {
        let mut result: (LitStr, LitStr) = (
            LitStr::new("", Span::call_site()),
            LitStr::new("", Span::call_site()),
        );
        if let Some(val) = config.app_config.get("template_dir") {
            if let ConfigAttrVal::Arr(arr) = val {
                if arr.len() == 2 {
                    if let ConfigAttrVal::Str(path) = &arr[0] {
                        if let ConfigAttrVal::Str(ext) = &arr[1] {
                            result = (path.clone(), ext.clone());
                        }
                    }
                }
            }
        }
        result
    };
    let mut handler_string = Vec::new();
    let mut handler_path: Vec<Path> = Vec::new();
    for handler in &config.handlers {
        handler_string
            .push(LitStr::new(&handler.call_string, Span::call_site()));
        let path = &handler.contr_path;
        let meth = &handler.contr_method;
        handler_path.push(parse_quote!(#path::#meth));
    }

    TokenStream::from(quote! {

        struct Storage {
            db: ::std::sync::OnceLock<::vicocomo::DatabaseIf>,
            server: ::std::sync::Mutex<::vicocomo::HttpServerImpl>,
            teng: ::vicocomo::TemplEngIf,
            teng_ok: ::std::sync::Mutex<bool>,
        }

        fn main() {
            use ::std::sync::{Arc, Mutex, OnceLock};
            use ::vicocomo::{TemplEng, TemplEngIf};
            ::tauri::Builder::default()
                .manage({
                    let teng = #teng_init;
                    let teng_ok = TemplEng::initialized(&teng);
                    Storage {
                        db: OnceLock::new(),
                        server: Mutex::new(#build_server),
                        teng: TemplEngIf::new(Arc::new(teng)),
                        teng_ok: Mutex::new(teng_ok),
                    }
                })
                .invoke_handler(::tauri::generate_handler![log, request])
                .run(::tauri::generate_context!())
                .expect("error while running tauri application");
        }

        #[::tauri::command]
        fn log(msg: &str) -> () {
          eprintln!("{}", msg);
        }

        #[::tauri::command(async)]
        fn request(
            app: ::tauri::AppHandle,
            storage: ::tauri::State<Storage>,
            method: &str,
            url: &str,
            body: &str,
        ) -> (u32, String) {
            use ::std::ops::Deref;
            use ::std::path::{Path, PathBuf};
            use ::std::sync::OnceLock;
            use ::url::Url;
            use ::vicocomo::{
                AppConfigVal, Controller, Error, HttpMethod, HttpParamVals,
                HttpRequestImpl, HttpReqBody, HttpResponse, HttpServer,
                HttpServerIf, HttpStatus,
            };
            use ::vicocomo_tauri::{
                BOUNDARY, fix_body, fix_response, fix_url,
                get_bool_str_res_path, get_db, tauri_response,
            };

            #[cfg(debug_assertions)]
            eprintln!("{method}  {url}\r\n  {}", body);

            static DATA_DIR_FIXED: OnceLock<()> = OnceLock::new();
            static RESOURCE_DIR_FIXED: OnceLock<()> = OnceLock::new();
            static TEXTS_CONFIG_FIXED: OnceLock<()> = OnceLock::new();

            let mut mth_str = method;
            let mut url_str = String::from(url);
            let mut url: Url;
            let mut body_str = body;
            let mut server = storage.server.lock().unwrap();
            DATA_DIR_FIXED.get_or_init(|| {
                // put data in the working directory while developing
                #[cfg(not(debug_assertions))]
                if if let Some(AppConfigVal::Str(s)) =
                        server.app_config("data_dir")
                    {
                        s.is_empty()
                    } else {
                        true
                    }
                {
                    if let Some(dir) = app.path_resolver().app_data_dir() {
                        server.add_cfg(
                            "data_dir",
                            ::vicocomo::AppConfigVal::Str(
                                dir.display().to_string()
                            ),
                        );
                    }
                }
            });
            RESOURCE_DIR_FIXED.get_or_init(|| {
                if if let Some(AppConfigVal::Str(s)) =
                        server.app_config("resource_dir")
                    {
                        s.is_empty()
                    } else {
                        true
                    }
                {
                    if let Some(dir) = app.path_resolver().resource_dir() {
                        server.add_cfg(
                            "resource_dir",
                            ::vicocomo::AppConfigVal::Str(
                                dir.display().to_string()
                            ),
                        );
                    }
                }
            });
            TEXTS_CONFIG_FIXED.get_or_init(|| {
                ::vicocomo::texts::initialize(
                    get_bool_str_res_path(
                        &server,
                        "texts_config",
                        "config/texts.cfg",
                    )
                    .as_ref()
                    .map(|pb| pb.as_path()),
                );
            });
            let db = storage.db.get_or_init(|| {
                ::vicocomo_tauri::get_db(
                    server
                        .app_config("data_dir")
                        .and_then(|dir| dir.str())
                        .map(|dir| PathBuf::from(&dir).join(#db_file))
                        .unwrap_or_else(|| PathBuf::from(#db_file))
                        .as_path(),
                    get_bool_str_res_path(
                        &server,
                        "create_db",
                        "db/schema.sql",
                    )
                    .as_ref()
                    .map(|pb| pb.as_path()),
                ).expect("cannot-open-sqlite")
            });
            let mut response: HttpResponse;
            loop {
                let mut body = body_str.as_bytes().to_vec();
                let mut boundary: Option<&str> = None;
                let (method, url) = match
                    HttpMethod::try_from(mth_str)
                        .and_then(|mth| {
                            fix_url(&url_str).map(|url| (mth, url))
                        })
                {
                    Ok(mth_url) => mth_url,
                    Err(e) =>  {
                        return (HttpStatus::BadRequest as u32, e.to_string());
                    }
                };
                if !HttpRequestImpl::is_loopback(&url) {
                    use ::rand::Rng;
                    let _ = ::tauri::WindowBuilder::new(
                        &app,
                        format!("{:0>16x}", ::rand::thread_rng().gen::<u64>()),
                        ::tauri::WindowUrl::External(url.clone()),
                    )
                        .build()
                        .map(|win| { let _ = win.set_title(&url.path()); });
                    return (0, String::new());
                }
                let teng = storage.teng.clone();
                let teng_ok = *storage.teng_ok.lock().unwrap();
                if !teng_ok {
                    let path = app.path_resolver()
                        .resolve_resource(#templ_dir)
                        .expect("failed to resolve resource")
                        .to_str()
                        .expect("template directory is not valid UTF8")
                        .to_string();
                    teng.register_templ_dir(&path, #templ_ext)
                        .expect("failed to register templates directory");
                    *storage.teng_ok.lock().unwrap() = true;
                }
                let mut parvals = {
                    let mut pv = HttpParamVals::new();
                    pv.set_request(body_str, url.query().unwrap_or(""));
                    pv
                };
                if let Some(mp_body) =
                    (method == HttpMethod::Post)
                    .then(|| &parvals)
                    .and_then(|pv| {
                        pv.get("__VICOCOMO__upload_name")
                            .map(|vector| vector[0].clone())
                    })
                    .and_then(|mp_name| fix_body(&mp_name, &parvals))
                {
                    body = mp_body;
                    boundary = Some(BOUNDARY);
                    parvals = HttpParamVals::new(); // necessary?
                }
                let request = {
                    let req = HttpRequestImpl::new(
                        method,
                        &url,
                        &[],
                        HttpReqBody::from_bytes(&body, boundary),
                        server.targets(),
                    );
                    if req.is_err() {
                        return tauri_response(server.not_found(method, &url));
                    }
                    req.unwrap()
                };
                response = match request.handler() {
                #(
                    #handler_string => #handler_path(
                        db.clone(),
                        HttpServerIf::new(server.deref(), &request),
                        teng.clone(),
                    ),
                )*
                    _ => panic!("This cannot happen"),
                };
                if response.get_status() == HttpStatus::SeeOther {
                    mth_str = "get";
                    url_str = response
                        .get_header("Location")
                        .unwrap_or(String::new());
                    body_str = "";
                } else {
                    return fix_response(response)
                        .map(|resp| tauri_response(resp))
                        .unwrap_or((0, String::new()));
                };
            }
        }
    })
}
