//! A trait and helper types to communicate to and from HTML forms.
//!
//#![allow(dead_code)]

use super::utils::*;
use crate::{texts::get_text, Error, HttpServerIf, SessionModel};
use ::serde::{Deserialize, Serialize};
use ::serde_json::value::{Map as JsonMap, Value as JsonValue};
use ::std::{
    fmt::{Debug, Display},
    str::FromStr,
    string::ToString,
};

// --- HtmlInput -------------------------------------------------------------

/// A tag or tags for input in an HTML `form`.
///
/// To keep track of the various HTML form input elements, a read-only
/// [`InputType`](enum.InputType.html) is set on creation.
///
/// `V` is the type of the value that is rendered and retrieved. (For the
/// multiple selection variants [`Checkbox`
/// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
/// ](enum.InputType.html#variant.SelectMult) it is the type of the elements
/// in the array of selected values.)
///
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct HtmlInput<V> {
    typ: InputType,
    vals: Vec<V>,
    opts: Vec<(String, V)>,
    // if we render more than one tag, this is a template, see render()
    tag: HtmlTag,
    lab: Option<String>,
    errs: Vec<String>,
}

impl<V> HtmlInput<V>
where
    V: Clone + Debug + Display + FromStr + PartialEq,
    <V as FromStr>::Err: Display,
{
    /// Create an empty object with the `ty` variant of [`InputType`
    /// ](enum.InputType.html).
    ///
    /// `name` is the input name.
    ///
    pub fn new(ty: InputType, name: &str) -> Self {
        Self {
            typ: ty,
            vals: Vec::new(),
            opts: Vec::new(),
            tag: ty.tag(name),
            lab: None,
            errs: Vec::new(),
        }
    }

    /// Add a value to an HTML attribute for the generated tag(s), see
    /// [`render()`](#method.render).
    ///
    /// For details see [`HtmlTag::add_attr_vals()`
    /// ](../utils/struct.HtmlTag.html#method.add_attr_vals).
    ///
    pub fn add_attr_vals(&mut self, attr: &str, value: &str) {
        self.tag.add_attr_vals(attr, value);
    }

    /// Add an error. See[`update()`](#method.update).
    ///
    pub fn add_error(&mut self, error: &str) {
        self.errs.push(error.to_string())
    }

    /// Clear the value, after which `get()` returns `None` and `get_mult()`
    /// returns an empty vector.
    ///
    pub fn clear(&mut self) {
        self.vals.clear();
    }

    /// Clear the errors generated by [`update()`](#method.update) or set by
    /// [`add_error()`](#method.add_error). See [`render()`](#method.render).
    ///
    pub fn clear_errors(&mut self) {
        self.errs.clear();
    }

    /// Clear the label. See [`render()`](#method.render).
    ///
    pub fn clear_label(&mut self) {
        self.lab = None;
    }

    /// Iterate over the errors generated by [`update()`](#method.update) or
    /// set by [`add_error()`](#method.add_error).
    ///
    pub fn error_iter(&self) -> ::std::slice::Iter<'_, String> {
        self.errs.iter()
    }

    /// Get the current value.
    ///
    /// <b>Note:</b> This method returns at most one value for the variants
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult).  Use [`get_mult()`
    /// ](#method.get_mult) to get all values.
    ///
    pub fn get(&self) -> Option<V> {
        if self.vals.is_empty() {
            None
        } else {
            Some(self.vals.first().unwrap().clone())
        }
    }

    /// Get all stored values.
    ///
    /// <b>Note:</b> For all except the multiple selection variants
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) this function never returns
    /// more than one value.
    ///
    pub fn get_mult(&self) -> Vec<V> {
        self.vals.clone()
    }

    /// The [type](enum.InputType.html) of the input.
    ///
    /// For the types that are rendered as one or more `input` tags this is
    /// the (capitalized) value of the `type` attribute. The exceptions are
    /// `Select`, `SelectMult`, and `Textarea`.
    ///
    pub fn get_type(&self) -> InputType {
        self.typ
    }

    /// Iterate over all stored values.
    ///
    /// <b>Note:</b> For all except the multiple selection variants
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) the iterator never yields
    /// more than one value.
    ///
    pub fn iter(&self) -> ::std::slice::Iter<'_, V> {
        self.vals.iter()
    }

    /// Prepend an error to the list of errors.
    ///
    pub fn prepend_error(&mut self, error: &str) {
        if self.errs.first().map(|e| e != error).unwrap_or(true) {
            self.errs.insert(0, error.to_string());
        }
    }

    /// Output a data structure to facilitate [rendering
    /// ](../../http_server/struct.TemplEngIf.html#method.render) the field.
    /// See the [example](#example).
    ///
    /// The output is a JSON `Object` that has two keys, `"errors"` and
    /// `"data"`.
    ///
    /// ## `"errors":`
    ///
    /// This is a JSON `Array` of JSON `String`s as generated by
    /// [`update()`](#method.update) or set by [`add_error()`
    /// ](#method.add_error).
    ///
    /// The JSON `String`s are [localized](../texts/index.html).
    ///
    /// ## `"data":`
    ///
    /// This is a JSON `Object` (or, for [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio), a JSON `Array` of them).
    ///
    /// Each `Object` has two keys, `"label"` and `"tag"`.
    ///
    /// The <b>tag</b> is a JSON `String`. It inlcudes inner HTML and end tag
    /// for [`Select`](enum.InputType.html#variant.Select), [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult), and [`Textarea`
    /// ](enum.InputType.html#variant.Textarea).
    ///
    /// The `id` attribute of the generated tag is as set with
    /// [`set_attr("id", _)`](#method.set_attr). If not set, the default is
    /// the [name](#method.new). For [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio) the [value](#method.set_options)
    /// is appended to get a unique `id` for each `input` tag.
    ///
    /// The <b>label</b> is as set by [`set_label()`](#method.set_label)
    /// except for [`Checkbox`](enum.InputType.html#variant.Checkbox) and
    /// [`Radio`](enum.InputType.html#variant.Radio) where the labels are
    /// taken from the [options](#method.set_options). For all types the
    /// resulting label text is [localized](../texts/index.html).
    ///
    /// If no label is set, the label will be JSON `null`. To get labels for
    /// checkboxes and radio buttons you need to [`set_label("")`
    /// ](#method.set_label).
    ///
    /// ### `input` tags
    ///
    /// For those, the `type` attribute is set according to the [`InputType`
    /// ](#method.new). The `value` is as set by [`set()`](#method.set).
    /// Again, the exceptions are [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio) where the `value` is taken from
    /// the [options](#method.set_options).
    ///
    /// Other HTML attributes set by [`add_attr_vals()`
    /// ](#method.add_attr_vals) or [`set_attr()`](#method.set_attr) also go
    /// to (all) `input` tags.
    ///
    /// ### `select` tag
    ///
    /// For [`Select`](enum.InputType.html#variant.Select) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult), the `option` texts and
    /// values are taken from the [options](#method.set_options).  The option
    /// texts are [localized](../texts/index.html). HTML attributes set by
    /// [`add_attr_vals()`](method.add_attr_vals) or [`set_attr()`
    /// ](#method.set_attr) go to the `select` tag.
    ///
    /// ### `textarea` tag
    ///
    /// For [`Textarea`](enum.InputType.html#variant.Textarea), the value,
    /// attributes, and (if set) label are rendered in the obvious way.
    ///
    /// ## Example
    /// ```
    /// use chrono::NaiveDate;
    /// use serde_json::json;
    /// use vicocomo::{HtmlInput, InputType};
    ///
    /// let mut input: HtmlInput<NaiveDate> =
    ///     HtmlInput::new(InputType::Date, "dat");
    /// input.set_attr("id", Some("some-id"));
    /// input.set("2020-02-02".parse().unwrap());
    /// input.add_attr_vals("class", " a");
    /// input.add_attr_vals("class", "b c \n");
    ///
    /// assert_eq!(
    ///     input.render(),
    ///     json!({
    ///         "errors": [],
    ///         "data": {
    ///             "label": null,
    ///             "tag": concat!(
    ///                 r#"<input type="date" id="some-id" name="dat""#,
    ///                 r#" value="2020-02-02" class="a b c">"#,
    ///             ),
    ///         },
    ///     }),
    /// );
    ///
    /// input.set_label("some-label");
    /// input.add_error("some-error");
    /// input.add_error("another");
    /// assert_eq!(
    ///     input.render(),
    ///     json!({
    ///         "errors": ["some-error", "another"],
    ///         "data": {
    ///             "label": r#"<label for="some-id">some-label</label>"#,
    ///             "tag": concat!(
    ///                 r#"<input type="date" id="some-id" name="dat""#,
    ///                 r#" value="2020-02-02" class="a b c">"#,
    ///             ),
    ///         },
    ///     }),
    /// );
    /// ```
    pub fn render(&self) -> JsonValue {
        match self.typ {
            InputType::Checkbox | InputType::Radio => self.rend_tags(),
            _ => self.rend_tag(),
        }
    }

    /// Set the current value, e.g. to initialize before `render()`ing.
    ///
    /// For the variants [`Radio`](enum.InputType.html#variant.Radio) and
    /// [`Select`](enum.InputType.html#variant.Select) the `value` is removed
    /// if it is not one of the options as set by [`set_options()`
    /// ](#method.set_options).
    ///
    /// <b>Note:</b> This method removes all values except `value` from the
    /// multiple selection variants [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult).  Use [`set_mult()`
    /// ](#method.get_mult) to set more than one value.
    ///
    pub fn set(&mut self, value: V) {
        self.vals.clear();
        self.vals.push(value);
        self.sanitize();
    }

    /// Set an attribute value for the generated HTML fragment, see
    /// [`render()`](#method.render).
    ///
    /// For details see [`HtmlTag::set_attr()`
    /// ](../utils/struct.HtmlTag.html#method.set_attr).
    ///
    pub fn set_attr(&mut self, attr: &str, values: Option<&str>) {
        self.tag.set_attr(attr, values);
    }

    /// Set the label to use when [rendering](#method.render) the generated
    /// HTML fragment. If this method is never called, no label(s) will be
    /// generated.
    ///
    pub fn set_label(&mut self, label: &str) {
        self.lab = Some(label.to_string());
    }

    /// Set the stored values in the multiple selection variants [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.Checkbox).
    ///
    /// Silently removes any element in `values` that is not among the
    /// [set options](#method.set_options).
    ///
    /// <b>Note:</b> ignores all `values` except the first for other variants.
    ///
    pub fn set_mult(&mut self, values: &[V]) {
        self.vals.clear();
        self.vals.extend_from_slice(values);
        self.sanitize();
    }

    /// Set the available options in the selection types [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox), [`Radio`
    /// ](enum.InputType.html#variant.Radio), [`Select`
    /// ](enum.InputType.html#variant.Select), and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult).
    ///
    /// `options` is a slice of pairs of option text and option value. For
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio) the text goes to the labels, for
    /// [`Select`](enum.InputType.html#variant.Select) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) they go to `option`'s inner
    /// HTML. The texts are [localized](../texts/index.html) by [`render()`
    /// ](#method.render).
    ///
    /// Also silently removes all existing values that are not in the new
    /// option set.
    ///
    /// <b>Note:</b> This method is meaningless for other variants.
    ///
    pub fn set_options(&mut self, options: &[(&str, V)]) {
        self.opts.clear();
        self.opts
            .extend(options.iter().map(|(s, v)| (s.to_string(), v.clone())));
        self.sanitize();
    }

    /// Update `self` from a JSON value.
    ///
    /// For the multiple selection variants [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) the `json` should be a JSON
    /// array of JSON strings. For other variants it should be a JSON string.
    ///
    /// If conversion fails, keep the old value(s) and return an error. The
    /// failure may be because the string cannot be parsed as the field's Rust
    /// type, or because the field is one of the selection types and a value
    /// in `json` is not among the current [options](#method.set_options).
    ///
    /// On error, one or more error messages are stored in [`self`
    /// ](#method.error_iter), an error message `"update"` is prepended to
    /// them, and the returned error is `InvalidInput("update")`.
    ///
    pub fn update(&mut self, json: &JsonValue) -> Result<(), Error> {
        match self.typ {
            InputType::Checkbox | InputType::SelectMult => {
                self.parse_json_arr(json)
            }
            _ => self.parse_json_str(json).map(|v| vec![v]),
        }
        .and_then(|received_vals| {
            let old_vals = self.vals.clone();
            let received_len = received_vals.len();
            self.vals = received_vals;
            self.sanitize();
            if self.vals.len() == received_len {
                Some(())
            } else {
                self.vals = old_vals;
                self.errs.insert(0, json.to_string());
                None
            }
        })
        .ok_or_else(|| {
            self.errs.insert(0, "update".to_string());
            Error::invalid_input("update")
        })
    }

    // - - private - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    fn parse_json_arr(&mut self, json: &JsonValue) -> Option<Vec<V>> {
        if let JsonValue::Array(arr) = json {
            let mut result = Vec::new();
            for leaf in arr {
                if let Some(val) = self.parse_json_str(leaf) {
                    result.push(val);
                }
            }
            if self.errs.is_empty() {
                Some(result)
            } else {
                None
            }
        } else {
            self.errs.push(json.to_string());
            None
        }
    }

    fn parse_json_str(&mut self, json: &JsonValue) -> Option<V> {
        if let JsonValue::String(s) = json {
            s.parse::<V>()
                .map_err(|e| {
                    self.errs.push(s.to_string());
                    self.errs.push(e.to_string());
                    e
                })
                .ok()
        } else {
            self.errs.push(json.to_string());
            None
        }
    }

    fn rend_errs(&self) -> JsonValue {
        JsonValue::Array(
            self.errs
                .iter()
                .map(|e| JsonValue::String(get_text(&e.to_string(), &[])))
                .collect(),
        )
    }

    fn rend_label(tag: &HtmlTag, lab: Option<&str>) -> JsonValue {
        lab.map(|l| {
            JsonValue::String(format!(
                "<label for=\"{}\">{}</label>",
                &tag.get_attr_first("id").unwrap(),
                &get_text(l, &[]),
            ))
        })
        .unwrap_or(JsonValue::Null)
    }

    fn rend_tag(&self) -> JsonValue {
        let mut result = JsonMap::new();
        result.insert("errors".to_string(), self.rend_errs());
        result.insert(
            "data".to_string(),
            Self::rend_tag_do(self.lab.as_deref(), &self.tag),
        );
        JsonValue::Object(result)
    }

    // panics if tag has no "id" attribute
    fn rend_tag_do(lab: Option<&str>, tag: &HtmlTag) -> JsonValue {
        let mut result = JsonMap::new();
        result.insert("label".to_string(), Self::rend_label(tag, lab));
        result.insert("tag".to_string(), JsonValue::String(tag.to_string()));
        JsonValue::Object(result)
    }

    // panics if self.tag has no "id" or "name" attributes
    fn rend_tags(&self) -> JsonValue {
        let id = self.tag.get_attr_first("id").unwrap();
        let mut result = JsonMap::new();
        result.insert("errors".to_string(), self.rend_errs());
        let mut inputs = Vec::new();
        for (lab, val) in &self.opts {
            let mut tag = self.tag.clone();
            tag.set_attr("id", Some(&(id.clone() + "--" + &val.to_string())));
            if let InputType::Checkbox = self.typ {
                tag.set_attr(
                    "name",
                    Some(&(tag.get_attr_first("name").unwrap() + "[]")),
                );
            }
            tag.set_attr("value", Some(&val.to_string()));
            if self.vals.contains(&val) {
                tag.set_attr("checked", None);
            }
            inputs.push(Self::rend_tag_do(
                // use the presence of *self.lab* as a flag to render *lab*
                self.lab.as_ref().map(|_| lab.as_str()),
                &tag,
            ));
        }
        result.insert("data".to_string(), JsonValue::Array(inputs));
        JsonValue::Object(result)
    }

    fn sanitize(&mut self) {
        // mutliple values only for the multiple selection variants
        match self.typ {
            InputType::Checkbox | InputType::SelectMult => (),
            _ => self.vals.truncate(1),
        }
        match self.typ {
            // for checkbox, radio, and select, remove vals not in opts
            InputType::Checkbox
            | InputType::Radio
            | InputType::Select
            | InputType::SelectMult => {
                let opts = &self.opts;
                self.vals
                    .retain(|v| opts.iter().find(|(_, o)| o == v).is_some());
            }
            // for textarea, no opts, sync tag text with vals
            InputType::Textarea => {
                self.opts = Vec::new();
                self.tag.clear_inner();
                match self.vals.first() {
                    Some(val) => self.tag.push_text(&val.to_string()),
                    _ => (),
                }
            }
            // for other types, no opts, sync tag value with vals
            _ => {
                self.opts = Vec::new();
                match self.vals.first() {
                    Some(v) => {
                        self.tag.set_attr("value", Some(&v.to_string()));
                    }
                    None => self.tag.drop_attr("value"),
                }
            }
        }
        // for select types, set tag options
        match self.typ {
            InputType::Select | InputType::SelectMult => {
                self.tag.clear_inner();
                for (txt, val) in &self.opts {
                    let mut opt = HtmlTag::new("option");
                    opt.set_attr("value", Some(&val.to_string()));
                    if self.vals.contains(&val) {
                        opt.set_attr("selected", None);
                    }
                    opt.push_text(txt);
                    self.tag.push_tag(opt);
                }
            }
            _ => (),
        }
    }
}

fn json_error(json: &JsonValue) -> Error {
    Error::invalid_input(json.to_string().as_str())
}

/// The type and current value of a form input, see [`HtmlInput`
/// ](struct.HtmlInput.html).
///
#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
pub enum InputType {
    /// Zero or more `<input type="checkbox" ` ... `>`.
    ///
    /// <b>Note:</b> This variant is error-prone if the stored values are of a
    /// floating point type because of rounding errors when comparing input
    /// values to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    Checkbox,

    /// One `<input type="date" `...` >`
    ///
    Date,

    /// One `<input type="email" `...` >`
    ///
    Email,

    /// One `<input type="hidden" `...` >`
    ///
    Hidden,

    /// One `<input type="number" `...` >`
    ///
    Number,

    /// One `<input type="password" `...` >`
    ///
    Password,

    /// Zero or more `<input type="radio" `...` >`.
    ///
    /// <b>Note:</b> This variant is error-prone if the stored value is of a
    /// floating point type because of rounding errors when comparing an input
    /// value to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    Radio,

    /// One `<input type="range" `...` >`
    ///
    Range,

    /// One `<input type="search" `...` >`
    ///
    Search,

    /// One `<select `...` > <option `...` > `...` </option> `...` </select>`
    ///
    /// <b>Note:</b> This variant is error-prone if the stored value is of a
    /// floating point type because of rounding errors when comparing an input
    /// value to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    Select,

    /// One `<select `...` multiple> `...` </select>`
    ///
    /// <b>Note:</b> This variant is error-prone if the stored values are of a
    /// floating point type because of rounding errors when comparing input
    /// values to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    SelectMult,

    /// One `<input type="text" `...` >`
    ///
    Text,

    /// One `<textarea `...` > `...` </textarea>`
    ///
    Textarea,

    /// One `<input type="url" `...` >`
    ///
    Url,
}

impl InputType {
    fn tag(self, name: &str) -> HtmlTag {
        let mut result = match self {
            Self::Checkbox => Self::input_tag("checkbox"),
            Self::Date => Self::input_tag("date"),
            Self::Email => Self::input_tag("email"),
            Self::Hidden => Self::input_tag("hidden"),
            Self::Number => Self::input_tag("number"),
            Self::Password => Self::input_tag("password"),
            Self::Radio => Self::input_tag("radio"),
            Self::Range => Self::input_tag("range"),
            Self::Search => Self::input_tag("search"),
            Self::Text => Self::input_tag("text"),
            Self::Select => HtmlTag::new("select"),
            Self::SelectMult => {
                let mut result = HtmlTag::new("select");
                result.set_attr("multiple", None);
                result
            }
            Self::Textarea => HtmlTag::new("textarea"),
            Self::Url => Self::input_tag("url"),
        };
        result.set_attr("id", Some(name));
        result.set_attr("name", Some(name));
        result
    }

    fn input_tag(typ: &str) -> HtmlTag {
        let mut result = HtmlTag::new("input");
        result.add_attr_vals("type", typ);
        result
    }
}

// --- html_form -------------------------------------------------------------

/// A trait for generating an HTML form and handling the input from it.
///
/// Not intended for manual derive, use the [derive macro
/// ](../../../vicocomo_html_macros/derive.HtmlForm.html).
///
/// ## Examples
///
/// There is a more elaborate example in the `examples/html/html_form`
/// directory.
///
/// ### Inferring or setting input types
/// ```
/// use chrono::NaiveDate;
/// use ::serde_json::json;
/// use ::vicocomo::{HtmlForm, HtmlInput};
///
/// #[derive(Clone, HtmlForm)]
/// struct BigForm {                                // Rust type or trait,
/// //------------------------------------------------------------------------
///     errors: Vec<String>,
///     // <input type="number" ... >
///     // Num => default InputType::Number
///     num: HtmlInput<i32>,                        // Num
///     // <input type="range" ... >
///     #[vicocomo_html_input_type = "Range"]
///     rng: HtmlInput<u32>,                        // Num
///     // <input type="text" ... >
///     // String => default InputType::Text
///     lin: HtmlInput<String>,                     // String
///     // <textarea ... > ... </textarea>
///     #[vicocomo_html_input_type = "Textarea"]
///     txt: HtmlInput<String>,                     // String
///     // <input type="hidden" ... >
///     #[vicocomo_html_input_type = "Hidden"]
///     // vicocomo_html_input_type may be Email, Password, Search, Url =>
///     // <input type="email", ...>, ... <input type="url" ...>
///     hid: HtmlInput<String>,                     // String
///     // <input type="date" ... >
///     // NaiveDate => default InputType::Date
///     dat: HtmlInput<NaiveDate>,                  // NaiveDate
///     // <select ... > ... </select>
///     #[vicocomo_html_input_type = "Select"]
///     sel: HtmlInput<u32>,                        // any
///     // <input type="radio" ... > ... one button per set_options() element
///     #[vicocomo_html_input_type = "Radio"]
///     rad: HtmlInput<i32>,                        // any
///     // <select ... multiple> ... </select>
///     #[vicocomo_html_input_type = "SelectMult"]
///     mul: HtmlInput<i64>,                        // any
///     // <input type="checkbox" ... > ... one box per set_options() pair
///     #[vicocomo_html_input_type = "Checkbox"]
///     chk: HtmlInput<String>,                     // any
///     // A field that is largely ignored by the derive macro
///     foo: Option<String>,
/// }
///
/// let mut big = BigForm::new();
///
/// // numeric field
/// big.num.set(17i32);
/// assert_eq!(big.num.get().unwrap(), 17i32);
/// assert!(big.update(&json!({"num": "42"})).is_ok());
/// assert_eq!(big.num.get().unwrap(), 42i32);
///
/// // CheckBox, Radio, Select, and SelectMult need an (option, value) list
/// big.sel.set_options(&[("a", 1), ("b", 42)]);
/// big.rad.set_options(&[("a", 1), ("b", -42)]);
/// big.mul.set_options(&[("a", 1), ("b", ::std::i64::MIN)]);
/// big.chk.set_options(&[("a", "x".to_string()), ("b", "y".to_string())]);
/// assert!(
///     big.update(&json!({
///         "num": "17",
///         "rng": "42",
///         "lin": "line",
///         "txt": "text",
///         "hid": "hidden",
///         "dat": "2020-02-02",
///         "sel": "42",
///         "rad": "-42",
///         "mul": ["-9223372036854775808", "1"],
///         "chk": ["x"],
///     }))
///     .is_ok(),
/// );
/// ```
///
/// ### Rendering
/// ```
/// use ::serde_json::json;
/// use ::vicocomo::{HtmlForm, HtmlInput};
///
/// #[derive(Clone, HtmlForm)]
/// struct SmallForm {
///     errors: Vec<String>,
///     num: HtmlInput<u32>,
///     #[vicocomo_html_input_type = "Radio"]
///     rad: HtmlInput<i32>,
///     #[vicocomo_html_input_type = "SelectMult"]
///     mul: HtmlInput<i64>,
///     foo: Option<String>,
/// }
///
/// let mut small = SmallForm::with_labels(Some("pre"));
///
/// small.rad.set_options(&[("a", 1), ("b", -42)]);
/// small.mul.set_options(&[("p", 1), ("n", 0), ("m", -1)]);
///
/// assert!(small
///     .update(&json!({
///         "num": "17",
///         "rad": "-42",
///         "mul": ["-1", "1"],
///     }))
///     .is_ok(),
/// );
///
/// assert_eq!(
///     small.to_json(),
///     json!({
///         "foo": null,
///         "mul": {
///             "errors": [],
///             "data": {
///                 "label": r#"<label for="mul">pre--SmallForm--mul--label</label>"#,
///                 "tag": concat!(
///                     r#"<select multiple id="mul" name="mul">"#,
///                     r#"<option value="1" selected>p</option>"#,
///                     r#"<option value="0">n</option>"#,
///                     r#"<option value="-1" selected>m</option>"#,
///                     r#"</select>"#,
///                 ),
///             },
///         },
///         "num": {
///             "errors": [],
///             "data": {
///                 "label": r#"<label for="num">pre--SmallForm--num--label</label>"#,
///                 "tag": r#"<input type="number" id="num" name="num" value="17">"#,
///             },
///         },
///         "rad": {
///             "errors": [],
///             "data": [
///                 {
///                   "label": r#"<label for="rad--1">a</label>"#,
///                   "tag": r#"<input type="radio" id="rad--1" name="rad" value="1">"#,
///                 },
///                 {
///                   "label": r#"<label for="rad---42">b</label>"#,
///                   "tag": r#"<input type="radio" id="rad---42" name="rad" value="-42" checked>"#,
///                 }
///             ],
///         },
///     }),
/// );
/// ```
pub trait HtmlForm: Clone + Sized {
    /// Add an error. See [`update()`](#tymethod.update).
    ///
    fn add_error(&mut self, error: &str);

    /// Clear the errors generated by [`update()`](#tymethod.update) or set by
    /// [`add_error()`](#tymethod.add_error) and call [`clear_errors()`
    /// ](struct.HtmlInput.html#method.clear_errors) in all `HtmlInput`
    /// fields. See [`to_json()`](#tymethod.to_json).
    ///
    fn clear_errors(&mut self);

    /// Iterate over the errors generated by [`update()`](#tymethod.update) or
    /// set by [`add_error()`](#tymethod.add_error).
    ///
    fn error_iter(&self) -> ::std::slice::Iter<'_, String>;

    /// Add the error error messages in `error` to those in the form and its
    /// `HtmlInput` fields.
    ///
    /// For `Error` variants [`CannotSave`
    /// ](../../error/enum.Error.html#variant.CannotSave) and [`CannotDelete`
    /// ](../../error/enum.Error.html#variant.CannotDelete), the field error
    /// texts are added by [`HtmlInput.add_error()`
    /// ](struct.HtmlInput.html#method.add_error) to the corresponding field
    /// in `self`, matching the field names in the [`ModelError`
    /// ](../../error/struct.ModelError.html) in `error` with `self`s field
    /// identifiers.
    ///
    /// In case the field names differ, `translate` should contain a pair
    /// `(*name in `error`*`, `*name in `self`*`)`. A field in `error` that
    /// has no match or translation is silently ignored.
    ///
    /// Non-field error texts, and texts from other [`Error`
    /// ](../../error/enum.Error.html) variants, are added by
    /// [`self.add_error()`](#tymethod.add_error).
    ///
    /// For the formatting of the texts, see the implementation of [`Display`
    /// for `Error`](../../error/enum.error.html#display-examples).
    ///
    /// ## Example
    /// ```
    /// use serde_json::{json, to_value};
    /// use vicocomo::{cannot_save, HtmlForm, HtmlInput};
    /// #[derive(Clone, HtmlForm)]
    /// struct ExampleForm {
    ///     errors: Vec<String>,
    ///     fld: HtmlInput<u32>,
    /// }
    /// let mut form = ExampleForm::new();
    /// assert!(form.update(&json!({ "fld": "17" })).is_ok());
    /// assert!(form.update(&json!({ "fld": "fortytwo" })).is_err());
    /// assert_eq!(to_value(form.fld.get_mult()).unwrap(), json!([17]));
    /// assert_eq!(
    ///     form.error_iter().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         &serde_json::to_string(&json!({ "fld": "fortytwo" })).unwrap(),
    ///     ],
    /// );
    /// assert_eq!(
    ///     form.error_iter().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         &serde_json::to_string(&json!({
    ///             "fld": "fortytwo",
    ///         })).unwrap(),
    ///     ],
    /// );
    /// assert_eq!(
    ///     form.fld.error_iter().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         "fortytwo",
    ///         "invalid digit found in string",
    ///     ],
    /// );
    /// let error = cannot_save!(
    ///     "SomeModel": "breaks-business-rules",
    ///     "fld_alias": ["required"],
    /// );
    /// form.merge_error(&error, &[("fld_alias", "fld")]);
    /// assert_eq!(to_value(form.fld.get_mult()).unwrap(), json!([17]));
    /// assert_eq!(
    ///     form.fld.error_iter().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         "fortytwo",
    ///         "invalid digit found in string",
    ///         "error--CannotSave--SomeModel--fld_alias--required",
    ///     ],
    /// );
    /// ```
    fn merge_error(&mut self, error: &Error, translate: &[(&str, &str)]);

    /// Prepend an error to the list of errors.
    ///
    fn prepend_error(&mut self, error: &str);

    /*
    /// Output an HTML form, unescaped. This will be a basic form, with no
    /// control over the generated HTML except that implied by the field
    /// attributes, see the [examples](#examples).
    ///
    /// If, as is often the case, you need more finetuning of the HTML, use
    /// [`to_json()`](#tymethod.to_json).
    ///
    fn to_form(&self) -> String;
    */

    /// Output a JSON object suitable for sending to the [template engine
    /// ](../../http_server/struct.TemplEngIf.html#method.render).
    ///
    /// See the [examples](#examples) for details.
    ///
    fn to_json(&self) -> JsonValue;

    /// Store the form in the [session
    /// ](../../session_model/trait.SessionModel.html#method.store) and, if
    /// successful, [`to_json()`](#tymethod.to_json).
    ///
    fn to_json_session(&self, srv: HttpServerIf) -> Result<JsonValue, Error>
    where
        Self: SessionModel,
    {
        self.store(srv).map(|_| self.to_json())
    }

    /// Output a JSON object containing all the `HtmlInput` field values
    /// `{"<field name>": <self.get_mult() as JSON Array>, ... }`.
    ///
    fn to_json_values(&self) -> JsonValue;

    /// Update all [`HtmlInput`](struct.HtmlInput.html) fields in `self` from
    /// `json`, which should be a JSON object with keys corresponding to the
    /// fields in `Self`.
    ///
    /// A field with no corresponding entry in `json` is not updated.
    ///
    /// A key that does not correspond to any field is ignored.
    ///
    /// If something goes wrong no field values are updated, the field
    /// specific error messages are stored in the `HtmlInput` fields, general
    /// error messages are stored by [`add_error()`](#tymethod.add_error), and
    /// an error message `"update"` is [prepended](#tymethod.prepend_error) to
    /// the general ones. The returned error is an [`InvalidInput("update")`
    /// ](../../error/enum.Error.html#variant.InvalidInput).
    ///
    /// <b>Tip:</b> `update()`, though intended primarily to be called with
    /// data received by the [HTTP server
    /// ](../../http_server/struct.HttpServerIf.html#method.param_json), may
    /// also be used before calling `to_json()`, to set many of the
    /// `HtmlInput` field values at once by using the [`serde_json::json`
    /// ](../../../serde_json/macro.json.html) macro to set the parameter
    /// `json`. See the [examples](#examples).
    ///
    fn update(&mut self, json: &JsonValue) -> Result<(), Error>;

    /// Create and update the object:
    ///
    /// - If field values were stored in the session by [`to_json_session()`
    ///   ](#tymethod.to_json_session), these are [loaded
    ///   ](../../session_model/trait.SessionModel.html#method.load) ...
    ///
    /// - ... and [removed
    ///   ](../../http_server/struct.HttpServerIf.html#method.session_remove)
    ///   from the session.
    ///
    /// - The fields are updated from `json` by [`update()`
    /// ](#tymethod.update).
    ///
    /// The created and possibly partially updated object is returned also on
    /// error, since the state loaded from the web session and error messages
    /// from the `HtmlInput` fields are stored there.
    ///
    fn update_session(
        srv: HttpServerIf,
        json: &JsonValue,
    ) -> Result<Self, Self>
    where
        Self: SessionModel,
    {
        let mut obj = Self::load(srv);
        srv.session_remove(Self::key());
        match obj.update(json) {
            Ok(_) => Ok(obj),
            Err(_) => Err(obj),
        }
    }
}
