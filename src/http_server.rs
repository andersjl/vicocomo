//! Structs and traits implemented by HTTP server adapter and used by web
//! application developers.
//!
use crate::Error;
use ::core::{
    convert::TryFrom,
    fmt::{self, Display, Formatter},
};
use ::quote::format_ident;
use ::serde::{de::DeserializeOwned, Serialize};
use ::serde_json::Value as JsonValue;
use ::std::{cmp::Ordering, collections::HashMap};
use ::syn::{
    braced, parenthesized,
    parse::{Parse, ParseStream},
    parse_quote, token, Expr, Ident, Lit, LitStr, Path, Type,
};
use ::vicocomo_derive_utils::*;

// --- for web application developers ----------------------------------------

/// The Vicocomo interface to an HTTP server.  Parameter to the controller
/// methods called by the code generated by a server specific [`config`
/// ](struct.Config.html) macro.
///
#[derive(Clone, Copy)]
pub struct HttpServerIf<'a>(&'a dyn HttpServer);

impl<'a> HttpServerIf<'a> {
    /// Create an interface to the `server`. *Not to be used by web
    /// application developers, web server adapters only.*
    ///
    pub fn new(server: &'a impl HttpServer) -> Self {
        Self(server)
    }

    /// The parameter values in the URL (get) or body (post) as a
    /// `serde_json::Value`.
    ///
    /// The parameters may be structured Ã  la PHP:
    // No doc test, but see the unit test test_formdata()
    /// ```text
    /// smpl=1&arr[]=2&arr[]=3&map[a]=4&map[b]=5&deep[c][]=6&deep[c][]=7&deep[d]=8&mtrx[][]=9
    /// -> json!({
    ///     "smpl": "1",
    ///     "arr":  ["2", "3"],
    ///     "map":  { "a": "4", "b": "5" },
    ///     "deep": { "c": ["6", "7"], "d": "8" },
    ///     "mtrx": [["9"]],
    /// })
    /// ```
    /// Note that all leaf values are strings.
    ///
    pub fn param_json(&self) -> Result<JsonValue, Error> {
        FormData::parse(self.0.param_vals()).and_then(|fd| {
            ::serde_json::to_value(&fd)
                .map_err(|e| Error::invalid_input(&e.to_string()))
        })
    }

    /// The value of the parameter with `name` in the URL (get) or body (post)
    /// as a URL-decoded string.  For structured parameters, use
    /// [`param_json()`](#method.param_json)
    ///
    pub fn param_val(&self, name: &str) -> Option<String> {
        self.0.param_val(name)
    }

    /// The path part of the request, without scheme, host, or parameters.
    ///
    pub fn req_path(&self) -> String {
        self.0.req_path()
    }

    /// If registered as `"a/<p1>/<p2>"` and the HTTP path of the request is
    /// `"a/42/Hello"`, and a local variable `srv: HttpServerIf`, the
    /// following should hold:
    /// ```text
    /// assert!(srv.req_path_val("p1").unwrap() == "42");
    /// assert!(srv.req_path_val("p2").unwrap() == "Hello");
    /// assert!(srv.req_path_val("whatever") == None);
    /// ```
    pub fn req_path_val(&self, par: &str) -> Option<String> {
        self.0.req_path_val(par)
    }

    /// If registered as `"a/<p1>/<p2>"` and the HTTP path of the request is
    /// `"a/42/Hello"`, this will collect as
    /// ```text
    /// vec![
    ///     (String::from("p1"), String::from("42")),
    ///     (String::from("p2"), String::from("Hello")),
    /// ]
    /// ```
    pub fn req_path_vals(&self) -> Vec<(String, String)> {
        self.0.req_path_vals()
    }

    /// The body of the request.
    ///
    pub fn req_body(&self) -> String {
        self.0.req_body()
    }

    /// The requested HTTP URL, including scheme, path, and query.
    ///
    pub fn req_url(&self) -> String {
        self.0.req_url()
    }

    /// Set the body of the response
    ///
    pub fn resp_body(&self, txt: &str) {
        self.0.resp_body(txt)
    }

    /// Generate an internal server error response, replacing the body.
    ///
    pub fn resp_error(&self, err: Option<&Error>) {
        self.0.resp_error(err)
    }

    /// Generate an OK response, using the body.
    ///
    pub fn resp_ok(&self) {
        self.0.resp_ok()
    }

    /// Generate a redirect response, ignoring the body.
    ///
    pub fn resp_redirect(&self, url: &str) {
        self.0.resp_redirect(url)
    }

    /// Clear the entire session.
    ///
    pub fn session_clear(&self) {
        self.0.session_clear();
    }

    /// Return the session value for `key` as `T`.
    ///
    /// If there is no current value for `key`, or  the current value for
    /// `key` is not a `T`,`None` is returned.
    ///
    pub fn session_get<T>(&self, key: &str) -> Option<T>
    where
        T: DeserializeOwned,
    {
        self.0
            .session_get(key)
            .and_then(|s| serde_json::from_str(&s).ok())
    }

    /// Remove the `key`-value pair.
    ///
    pub fn session_remove(&self, key: &str) {
        self.0.session_remove(key)
    }

    /// Set a `value` for `key`.
    ///
    /// Returns an error if serializing fails.
    ///
    pub fn session_set<T>(&self, key: &str, value: &T) -> Result<(), Error>
    where
        T: Serialize,
    {
        self.0.session_set(
            key,
            &serde_json::to_string(value)
                .map_err(|e| Error::other(&e.to_string()))?,
        )
    }
}

/// The Vicocomo interface to a template rendering engine.  Parameter to the
/// controller methods called by the code generated by a server specific
/// [`config`](struct.Config.html) macro.
///
#[derive(Clone, Copy)]
pub struct TemplEngIf<'a>(&'a dyn TemplEng);

impl<'a> TemplEngIf<'a> {
    /// Create from a `TemplEng`. Intended for web server adapter developers.
    ///
    pub fn new(eng: &'a impl TemplEng) -> Self {
        Self(eng)
    }

    /// Render, filling out `tmpl` with `data`.
    ///
    pub fn render(
        &self,
        tmpl: &str,
        data: &impl Serialize,
    ) -> Result<String, Error> {
        self.0.render(
            tmpl,
            &::serde_json::to_value(data)
                .map_err(|e| Error::render(&e.to_string()))?,
        )
    }
}

// --- for web application and server adapter developers ---------------------

// - - Config documentation  - - - - - - - - - - - - - - - - - - - - - - - - -

/// A syntax tree node for configuring an HTTP server.  Intended for use in a
/// server specific `config` macro.
///
/// <b>Web application developers:</b> The HTTP server `vicocomo` adapter
/// crate defines a macro `config` that accepts input as documented here.
/// Knowledge of the structure and inner workings of `Config` is *not*
/// necessary for developing an application using that macro.
///
/// <b>HTTP server adapter developers:</b> There is an implementation for
/// [`actix-web`](https://crates.io/crates/actix-web) [here
/// ](../../vicocomo_actix/macro.config.html).
///
// TODO: named routes and url_for().
// TODO: implement not_found.
/// # Macro input syntax
///
/// A HTTP server adapter's `config` macro takes input of the form
/// ```text
/// level_1(value) { level_2 { level_3: value, ... }, ... }, ...
/// ```
/// where `level_1`, `level_2`, and `level_3` are identifiers while the
/// `value`s are
/// - `[` *an identifier*`, `...` ]`,
/// - *an identifer*,
/// - *a bool, char, float, integer, or string literal*,
/// - *a Rust path*, or
/// - `(` *a type*`, `*an expression*` )`,
///
/// The level 1
/// `value` and its parentheses are optional as well as the braced groups and
/// braces if empty. One `level_3` may be present without any `level_2`, and
/// in this case there should be a single pair of braces.
///
/// The combination of `level_1` and its `value` should be globally unique.
/// `level_2` and `level_3` should be unique within their brace group.
/// "Unique" means that a later entry will replace an earlier.
///
/// # Currently Recognized Arguments
///
/// ## Level 1 `app_config`
///
/// Various attributes configuring the generated application code. No level 1
/// value or level 2 identifiers. Globally recognized level 3 identifiers are
/// - `controller_prefix`: The value should be a Rust path that is the
///   controllers module prefix, see [`route`
///   ](#controller-path-and-handling-method) below. Optional, default
///   `crate::controllers`.
/// - `role_enum`: The value defines [role-based access control
///   ](#role-based-access-control). (RBAC) as follows:
///   <br><b>`false`:</b> RBAC is not used.
///   <br><b>`true`:</b> RBAC is used, and the role `enum` is
///   `crate::models::UserRole`.
///   <br><b>a Rust path:</b> RBAC is used, and the value is the path to the
///   role `enum`.
///   <br>Optional, default `true` if `role_variants` are defined, otherwise
///   `false`.
/// - `role_variants`: The value should be an array of role identifiers,
///   needed by the [authorization](#level-1-authorize) mechanism below.
///   <br>Ignored if `role_enum` is `false`. Otherwise optional, default an
///   empty array.
///   <br>The predefined role `Superuser` is added if omitted.
/// - `unauthorized_route`: The value should be a route to redirect to if
///   authentications fails.
///   <br>Ignored if `role_enum` is `false`. Otherwise optional, default "/".
///
/// A server adapter may use its own `app_config` attributes as needed.
///
/// ## Level 1 `authorize`
///
/// ### Role Based Access Control
///
/// RBAC may be implemented by giving the `app_config` attribute `role_enum` a
/// value that is not `false`.  The application must implement the trait
/// [`UserRole`](../authorization/trait.UserRole.html) for the role `enum`.
///
/// ### Route Pattern Authorization
///
/// The level 1 value (between parentheses) is an authorization pattern.  It
/// must match the entire route pattern, except that a slash at the beginning
/// is understood and optional. It may end with "/*", which matches "" and any
/// string starting with "/".
///
/// If there is no level 2 identifier: The level 3 identifier should be an
/// HTTP method (case insensitive). The value is the `role_variant` that is
/// authorized, or an array of them.
///
/// If there are level 2 identifiers, they should be case insensitive HTTP
/// methods. For each method, the level 3 identifier is either `allow` or
/// `filter`, and the value is again one or more `role_variant`s.
///
/// See below about the use of [`filter`](#filtering-access-control).
///
/// When choosing authorized roles, the longest (up to "/*") matching pattern
/// is used.  If two patterns have the same length and one of them ends in a
/// wildcard and the other not, the latter is chosen.  If none or both of them
/// ends in a wildcard, the first is chosen.
///
/// Example:
/// ```text
/// authorize("/my-route/*") { get { allow: SomeRole } },
/// authorize("/my-route/specific") { get { allow: OtherRole } },
/// authorize("/my-route/general/*") { get: ThirdRole },
/// ```
/// will authorize SomeRole to `/my-route`, `/my-route/whatever`, and
/// `my-route/specific/whatever` but not to `/my-route/specific`,
/// `/my-route/general`, or `/my-route/general/whatever`.
///
/// OtherRole is authorized only to `/my-route/specific`, while ThirdRole is
/// authorized to `/my-route/general` and `/my-route/general/whatever`.
///
/// The route pattern may include parameters in angle brackets, e.g.
/// `"path/<id>/with/<par>/two/parameters"`, which match any value in that
/// position in the actual path.
///
/// ### Predefined and Pseudo Roles
///
/// The predefined role `Superuser` is always authorized to everything,
/// ignoring route pattern authorization except if `filter`ed, see [below
/// ](#filtering-access-control).
///
/// A user that has the (optional) role `Disabled` is denied access to all
/// routes that do not explicitly allow `Disabled`.
///
/// The pseudo role `Authenticated` is equivalent to an array containing all
/// defined roles, including `Disabled`.
///
/// The pseudo role `Enabled` is equivalent to an array containing all defined
/// roles except `Disabled`.  If `Disabled` is not defined, this is equivalent
/// to `Authenticated`.
///
/// The pseudo role `Public` authorizes access to all clients, ignoring
/// authentication.
///
/// Apart from the predefined `Superuser` there can be any number of roles
/// with arbitrary names except the pseudo role names above. The application
/// must implement the role `enum` as defined by the [`app_config`
/// ](#level-1-app_config) attributes `role_enum` and `role_variants`.
///
/// ### Filtering Access Control
///
/// Using `filter` instead of `allow` when authorizing a role or an array of
/// them means that access is granted only if the handler controller's method
/// [`filter_access()`
/// ](../controller/trait.Controller.html#method.filter_access) returns true.
/// Use `filter` and override `filter_access()` e.g. to allow the logged in
/// user access to their own profile but noone elses, like so:
///
/// ```text
/// // in the config macro the route definition ...
/// route(User) { create, delete, edit_form, index, patch, show },
/// // ... will create the following paths:
/// //     create     POST  /user
/// //     delete     POST  /user/<id>/delete
/// //     edit_form  GET   /user/<id>/edit
/// //     index      GET   /user
/// //     patch      POST  /user/<id>
/// //     show       GET   /user/<id>
/// // and the authorization ...
///     authorize("/user/<id>/*") {
///         get { filter: Authenticated },
///         post { filter: Authenticated },
///     },
///     authorize("/user/<id>/delete") {
///         post { allow: [] },
///     },
/// // ... together with the following User controller code ...
///     impl Controller for User {
///         fn filter_access(db: DatabaseIf, srv: HttpServerIf) -> bool {
///             use crate::models::UserSession; // supposing a UserSession ...
///             srv.req_path_val("id")
///                 .map(|s| {           // ... with an auth_id() method
///                     s.parse::<u32>() == UserSession::auth_id(db, srv)
///                 })
///                 .unwrap_or(false)
///         }
///         // ... handlers etc
///     }
/// // ... will authorize a logged in user with id 42 to only the following
/// // routes:
/// //     GET   /user/42
/// //     GET   /user/42/edit
/// //     POST  /user/42/patch
/// ```
/// ### Token Authentication
///
/// TODO
///
/// ## Level 1 `plug_in`
///
/// Plug in an object implementing a `vicocomo` trait. Recognized level 1
/// values are identifiers:
/// - `DbConn`: The plug in implements [`DbConn`
///   ](../database/trait.DbConn.html). Optional, default [`NullConn`
///   ](../database/struct.NullConn.html).
/// - `Session`: The plug in implements [`Session`](trait.Session.html).
///   Optional, default [`NullSession`](struct.NullSession.html).
/// - `TemplEng`: The plug in mplements [`TemplEng`](trait.TemplEng.html).
///   Optional, default [`NullTemplEng`](struct.NullTemplEng.html).
///
/// All require no level 2 and one level 3 arg `def`:
/// ```text
/// plug_in(SomeTrait) {
///     def: (
///         <a type implementing vicocomo::SomeTrait>,
///         <an expression evaluating to an instance of the type>,
///     ),
/// },
/// ```
///
/// ## Level 1 `route` and `not_found`
///
/// Route configuration. At least one route must obviously be defined.
/// Example follows.  See [Controller path and handling method
/// ](#controller-path-and-handling-method) below for the meaning of
/// "*Control*" in `route(`*Control*`)`.
/// ```text
///                        // HTTP | Path (params in <>)  | ctrl | method
///                        // =====+======================+======+============
/// route(Rsrc) {          //   CRUD requests, only those given are generated
/// // Create request         -----+----------------------+------+------------
///   new_form,            // get  | "/rsrc/new"          | Rsrc | new_form
///   copy_form,           // get  | "/rsrc/<id>/copy"    | Rsrc | copy_form
///   create,              // post | "/rsrc"              | Rsrc | create
///   ensure,              // post | "/rsrc/ensure"       | Rsrc | ensure
/// // Read request           -----+----------------------+------+------------
///   index,               // get  | "/rsrc"              | Rsrc | index
///   show,                // get  | "/rsrc/<id>"         | Rsrc | show
/// // Update request         -----+----------------------+------+------------
///   edit_form,           // get  | "/rsrc/<id>/edit"    | Rsrc | edit_form
///   patch,               // post | "/rsrc/<id>"         | Rsrc | patch
///   replace,             // post | "/rsrc/<id>/replace" | Rsrc | replace
/// // Delete request         -----+----------------------+------+------------
///   delete,              // post | "/rsrc/<id>/delete"  | Rsrc | delete
/// },                     // =====+======================+======+============
/// route(Cust) {          //   Methods may be customized |      |
///   custom {             // -----+----------------------+------+------------
///     http_method: post, //   Default GET
///     path: "path",      // post | "/path"              | Cust | custom
/// }},                    // =====+======================+======+============
/// route(Sing) {          //   Example: configure a singleton resource
///   new_form,            // get  | "/sing/new"          | Sing | new_form
///   create,              // post | "/sing"              | Sing | create
///   ensure,              // post | "/sing/ensure"       | Sing | ensure
///   show                 //   Full path must be given if leading slash
///   { path: "/sing" },   // get  | "/sing"              | Sing | show
///   edit_form            //   Resource snake prepended if no leading slash
///   { path: "edit" },    // get  | "/sing/edit"         | Sing | edit_form
///   patch { path: "" },  // post | "/sing"              | Sing | patch
///   replace              //      |                      |      |
///   { path: "replace" }, // post | "/sing/replace"      | Sing | replace
///   delete               //      |                      |      |
///   { path: "delete" },  // post | "/sing/delete"       | Sing | delete
/// },                     // =====+======================+======+============
/// route(Othr) {          //   Customized path parameters are given as
///   parm_req { path:     // <param> (parameter name ignored)
///     "some/<param>",    // get  | "/some/<p0>"         | Othr | parm_req
///   },                   // -----+----------------------+------+------------
///   post_req {           //   Except for the standardized CRUD requests
///     http_method: post, // above, GET is the default HTTP method
///     path: "postpth",   // post | "/postpth"           | Othr | post_req
/// }},                    // =====+======================+======+============
/// // Not Found handler   //      |                      |      |
/// not_found(Hand) {func} //   All not handled elsewhere,| Hand | func
///                        // no default provided by parse()
/// ```
///
/// ### Controller Path and Handling Method
///
/// The controller is given as `some::path::to::Controller`. If the path is a
/// single identifier, as in the examples, the `controller_prefix` [attribute
/// ](#level-1-app_config) value (default `crate::controllers::`) is
/// prepended.
///
/// The handling methods are called as
/// `some::path::to::Controller::handler(...)`. So the controller may be a
/// module, struct, or enum as long as the handling method does not have a
/// receiver.
///
/// Handling method signature:
/// ```text
/// (
///     ::vicocomo::DatabaseIf,
///     ::vicocomo::HttpServerIf,
///     ::vicocomo::TemplEngIf,
/// ) -> ()
/// ```
/// Note that there is no return value. Errors should be forwarded using
/// methods in [`HttpServerIf`](struct.HttpServerIf.html).

// --- for HTTP server adapter developers only -------------------------------

// - - Config and friends  - - - - - - - - - - - - - - - - - - - - - - - - - -

#[derive(Clone, Debug)]
pub struct Config {
    /// The `Type` implements a trait `vicocomo::`*the `String`*.
    ///
    /// The `Expr` evaluates to the `Type`.
    ///
    pub plug_ins: HashMap<String, (Type, Expr)>,

    /// This will always contain the predefined entries (see [above
    /// ](#level-1-app_config))
    /// <br>`"controller_prefix" => ConfigAttrVal::Path(`*a Rust path*`)`,
    /// <br>`"role_enum" => ConfigAttrVal::Literal(false)`, or
    /// `ConfigAttrVal::Path(`*a Rust path to the role enum*`)`,
    /// <br>`"role_variants" => ConfigAttrVal::Array(`*a `Vec` with role ids*`)`,
    /// <br>`"unauthorized_route" => ConfigAttrVal::Literal(`*a route string*`)`,
    /// <br>An implementation is free to add HTTP server specific attributes.
    ///
    pub app_config: HashMap<String, ConfigAttrVal>,

    /// The routing targets, mapping a controller to its route handlers.
    ///
    pub routes: HashMap<Path, Vec<Handler>>,

    /// Optional custom handler for failed routes.
    ///
    pub not_found: Option<(Path, Ident)>,
}

/// # For HTTP server adapter developers only
///
/// The possible values of a level 3 configuration attribute.
///
#[derive(Clone, Debug)]
pub enum ConfigAttrVal {
    Array(Vec<Ident>),
    Ident(Ident),
    Literal(Expr),
    /// Note that the contained `Path` is never a single `Ident`.
    Path(Path),
    /// The expression should evaluate to an instance of the type.
    TypeExpr(Type, Expr),
}

macro_rules! literal_extractor {
    ($self: ident, $variant: ident $( , )? ) => {{
        let mut result = Err(syn_error(&$self.to_string()));
        match $self {
            ConfigAttrVal::Literal(e) => match e {
                Expr::Lit(lit) => match &lit.lit {
                    Lit::$variant(v) => {
                        result = Ok(v.clone());
                    }
                    _ => (),
                },
                _ => (),
            },
            _ => (),
        }
        result
    }};
}

impl ConfigAttrVal {
    /// Return the contained array or an error.
    ///
    pub fn get_array(&self) -> ::syn::Result<Vec<Ident>> {
        match self {
            ConfigAttrVal::Array(a) => Ok(a.clone()),
            _ => Err(syn_error(&format!("Not an Ident (array): {}", &self))),
        }
    }
    /// - A clone of the contained Array of Ident as String, or
    /// - the contained Ident as a vector with one String, or
    /// - an error.
    ///
    pub fn get_array_strings(&self) -> ::syn::Result<Vec<String>> {
        match self {
            ConfigAttrVal::Array(a) => {
                Ok(a.iter().map(|i| i.to_string()).collect())
            }
            ConfigAttrVal::Ident(i) => Ok(vec![i.to_string()]),
            _ => Err(syn_error(&format!("Not an Ident (array): {}", &self))),
        }
    }

    /// Return the contained boolean or an error.
    ///
    pub fn get_bool(&self) -> ::syn::Result<bool> {
        literal_extractor!(self, Bool).map(|b| b.value)
    }

    /// Return the contained character or an error.
    ///
    pub fn get_char(&self) -> ::syn::Result<char> {
        literal_extractor!(self, Char).map(|i| i.value())
    }

    /// Return the contained float or an error.
    ///
    pub fn get_f64(&self) -> ::syn::Result<f64> {
        literal_extractor!(self, Float).and_then(|f| f.base10_parse().into())
    }

    /// Return the contained integer or an error.
    ///
    pub fn get_i64(&self) -> ::syn::Result<i64> {
        literal_extractor!(self, Int).and_then(|i| i.base10_parse().into())
    }

    /// Return the contained identifier or an error.
    ///
    pub fn get_ident(&self) -> ::syn::Result<Ident> {
        match self {
            ConfigAttrVal::Ident(i) => Ok(i.clone()),
            _ => Err(syn_error(&format!("{} is not an Ident", &self))),
        }
    }

    /// Return the contained `LitStr` or an error.
    ///
    pub fn get_litstr(&self) -> ::syn::Result<LitStr> {
        literal_extractor!(self, Str)
    }

    /// Return the contained Rust path, or identifier as a path, or an error.
    ///
    pub fn get_path(&self) -> ::syn::Result<Path> {
        match self {
            ConfigAttrVal::Ident(i) => Ok(parse_quote!(#i)),
            ConfigAttrVal::Path(p) => Ok(p.clone()),
            _ => Err(syn_error(&format!("{} is not a Path", &self))),
        }
    }

    /// Return the contained string or an error.
    ///
    pub fn get_str(&self) -> ::syn::Result<String> {
        literal_extractor!(self, Str).map(|s| s.value())
    }

    /// Return the contained (Type, Expr) pair or an error.
    ///
    pub fn get_type_expr(&self) -> ::syn::Result<(Type, Expr)> {
        match self {
            ConfigAttrVal::TypeExpr(t, e) => Ok((t.clone(), e.clone())),
            _ => Err(syn_error(&format!("{} is not a (Type, Expr)", &self))),
        }
    }
}

impl Display for ConfigAttrVal {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        use ::itertools::Itertools;
        match self {
            Self::Array(v) => {
                write!(f, "[{}]", v.iter().map(|i| i.to_string()).join(", "))
            }
            Self::Ident(i) => write!(f, "{}", i.to_string()),
            Self::Literal(l) => write!(f, "{}", tokens_to_string(l)),
            Self::Path(p) => write!(f, "{}", tokens_to_string(p)),
            Self::TypeExpr(t, e) => write!(
                f,
                "({}, {})",
                tokens_to_string(t),
                tokens_to_string(e),
            ),
        }
    }
}

/// # For HTTP server adapter developers only
///
/// Information needed for implementing an HTTP server configuration macro
/// using [`Config`](struct.Config.html).
#[derive(Clone, Debug)]
pub struct Handler {
    /// only tested for Get and Post.
    ///
    pub http_method: HttpMethod,

    /// Route, possibly with path parameters in angle brackets.
    ///
    pub route: String,

    /// number of path parameters.
    ///
    pub route_par_count: usize,

    /// If `Some`, defines access control for `route`, see [`Authorized`
    /// ](struct.Authorized.html). If `None`, there is no access control.
    pub authorized: Option<Authorized>,

    /// controller method name.
    pub contr_method: Ident,
}

/// # For HTTP server adapter developers only
///
/// Used by a web server adapter to implement [role based access control
/// ](struct.Config.html#role-based-access-control), utilizing the role
/// `enum`'s [`is_authenticated()`
/// ](struct.Config.html#role-based-access-control) method.
///
/// A user that has the (optional) role `Disabled` should be allowed access
/// only if `Disabled` is present in `allow`.
///
/// A user that does not have the role `Disabled` should be allowed access if
/// any of its roles is present in `allow`.
///
/// Whether `Disabled` or not, if `filter` is `true` access should be allowed
/// only after [filtering](#filtering-access-control).
///
/// The role `Superuser` is guaranteed always to be present in `allow`.
///
#[derive(Clone, Debug)]
pub struct Authorized {
    /// Each `Expr` evaluates to a [role `enum`
    /// ](struct.Config.html#role-based-access-control).
    pub allow: Vec<Expr>,
    /// Allow access to the `allow` roles only after [filtering
    /// ](struct.Config.html#filtering-access-control).
    pub filter: bool,
}

/// # For HTTP server adapter developers only
///
/// A simple enum with the official methods.
///
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Hash)]
pub enum HttpMethod {
    Connect,
    Delete,
    Get,
    Head,
    Options,
    Patch,
    Post,
    Put,
    Trace,
}

impl Copy for HttpMethod {}

impl Display for HttpMethod {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Connect => "connect",
                Self::Delete => "delete",
                Self::Get => "get",
                Self::Head => "head",
                Self::Options => "options",
                Self::Patch => "patch",
                Self::Post => "post",
                Self::Put => "put",
                Self::Trace => "trace",
            }
        )
    }
}

impl TryFrom<&str> for HttpMethod {
    type Error = Error;
    fn try_from(s: &str) -> Result<Self, Error> {
        match s.to_lowercase().as_str() {
            "connect" => Ok(HttpMethod::Connect),
            "delete" => Ok(HttpMethod::Delete),
            "get" => Ok(HttpMethod::Get),
            "head" => Ok(HttpMethod::Head),
            "options" => Ok(HttpMethod::Options),
            "patch" => Ok(HttpMethod::Patch),
            "post" => Ok(HttpMethod::Post),
            "put" => Ok(HttpMethod::Put),
            "trace" => Ok(HttpMethod::Trace),
            &_ => Err(Error::other(&format!("{} is not an HTTP method", s))),
        }
    }
}

// - - HttpServer and friends  - - - - - - - - - - - - - - - - - - - - - - - -

/// # For HTTP server adapter developers only
///
/// Everything Vicocomo needs from an HTTP server.
///
pub trait HttpServer {
    /// See [`HttpServerIf::param_val()`
    /// ](struct.HttpServerIf.html#method.param_val).
    ///
    fn param_val(&self, name: &str) -> Option<String>;

    /// All parameter values in the URL (get) or body (post) as a vector of
    /// URL-decoded key-value pairs.
    ///
    fn param_vals(&self) -> Vec<(String, String)>;

    /// See [`HttpServerIf::req_path()`
    /// ](struct.HttpServerIf.html#method.req_path).
    ///
    fn req_path(&self) -> String;

    /// See [`HttpServerIf::req_path_val()`
    /// ](struct.HttpServerIf.html#method.req_path_val).
    ///
    fn req_path_val(&self, par: &str) -> Option<String>;

    /// See [`HttpServerIf::req_path_vals()`
    /// ](struct.HttpServerIf.html#method.req_path_vals).
    ///
    fn req_path_vals(&self) -> Vec<(String, String)>;

    /// See [`HttpServerIf::req_body()`
    /// ](struct.HttpServerIf.html#method.req_body).
    ///
    fn req_body(&self) -> String;

    /// See [`HttpServerIf::req_url()`
    /// ](struct.HttpServerIf.html#method.req_url).
    ///
    fn req_url(&self) -> String;

    /// See [`HttpServerIf::resp_body()`
    /// ](struct.HttpServerIf.html#method.resp_body).
    ///
    fn resp_body(&self, txt: &str);

    /// See [`HttpServerIf::resp_error()`
    /// ](struct.HttpServerIf.html#method.resp_error).
    ///
    fn resp_error(&self, err: Option<&Error>);

    /// See [`HttpServerIf::resp_ok()`](struct.HttpServerIf.html#method.resp_ok).
    ///
    fn resp_ok(&self);

    /// See [`HttpServerIf::resp_redirect()`
    /// ](struct.HttpServerIf.html#method.resp_redirect).
    ///
    fn resp_redirect(&self, url: &str);

    /// See [`HttpServerIf::session_clear()`
    /// ](struct.HttpServerIf.html#method.session_clear).
    ///
    fn session_clear(&self);

    /// See [`HttpServerIf::session_get()`
    /// ](struct.HttpServerIf.html#method.session_get), but the JSON is not
    /// decoded.
    ///
    fn session_get(&self, key: &str) -> Option<String>;

    /// See [`HttpServerIf::session_remove()`
    /// ](struct.HttpServerIf.html#method.session_remove).
    ///
    fn session_remove(&self, key: &str);

    /// See [`HttpServerIf::session_set()`
    /// ](struct.HttpServerIf.html#method.session_set), but the value is
    /// already JSON-serialized on entry.
    ///
    fn session_set(&self, key: &str, value: &str) -> Result<(), Error>;
}

/// # For HTTP server adapter developers only
///
/// Methods to store a session.  Use in a server specific [`config`
/// ](struct.Config.html) macro to enable session store plugin options.
///
pub trait Session {
    /// Clear the entire session.
    ///
    fn clear(&self);

    /// Retreive the value for `key` or `None` if not present.
    ///
    fn get(&self, key: &str) -> Option<String>;

    /// Remove the `key`-value pair.
    ///
    fn remove(&self, key: &str);

    /// Set a `value` for `key`.
    ///
    fn set(&self, key: &str, value: &str) -> Result<(), Error>;
}

/// # For HTTP server adapter developers only
///
/// An implementation of [`Session`](trait.Session.html) that does
/// nothing and returns `()`, `None`, or [`Error`](../error/enum.Error.html).
///
#[derive(Clone, Copy, Debug)]
pub struct NullSession;

impl Session for NullSession {
    fn clear(&self) {
        ()
    }
    fn get(&self, _key: &str) -> Option<String> {
        None
    }
    fn remove(&self, _key: &str) {
        ()
    }
    fn set(&self, _key: &str, _value: &str) -> Result<(), Error> {
        Err(Error::other("no session store defined"))
    }
}

// - - TemplEng and friends  - - - - - - - - - - - - - - - - - - - - - - - - -

/// # For HTTP server adapter developers only
///
/// Methods to render via a template engine.
///
pub trait TemplEng {
    /// Override to render.
    ///
    /// `data` is data for the template as `serde_json::Value`.
    ///
    #[allow(unused_variables)]
    fn render(&self, tmpl: &str, json: &JsonValue) -> Result<String, Error>;
}

/// # For HTTP server adapter developers only
///
/// An implementation of [`TemplEng`](trait.TemplEng.html) that does nothing
/// and returns [`Error`](../error/enum.Error.html).
///
#[derive(Clone, Copy, Debug)]
pub struct NullTemplEng;

impl TemplEng for NullTemplEng {
    fn render(
        &self,
        _tmpl: &str,
        _json: &JsonValue,
    ) -> Result<String, Error> {
        Err(Error::render("no template engine"))
    }
}

// --- private --------------------------------------------------------------

use ::regex::{CaptureMatches, Regex};
use ::std::iter::Peekable;

::lazy_static::lazy_static! {
    static ref PATH_PARAMS: Regex = Regex::new(r"(<[^>]*>)").unwrap();
}

// - - HttpServerIf helpers  - - - - - - - - - - - - - - - - - - - - - - - - -

#[derive(Clone, Debug)]
enum FormData {
    Arr(Vec<FormData>),
    Map(HashMap<String, FormData>),
    Leaf(String),
}

impl FormData {
    // Expect self to be a Map and value to be a Leaf.
    // Depending on more_keys.next():
    // - None => insert value in self at key
    // - "" => recurse to push() to the Arr in self at key, or create the Arr
    // - => recurse to insert() in the Map in self at key
    fn insert(
        &mut self,
        key: String,
        mut more_keys: Peekable<CaptureMatches>,
        value: Self,
    ) -> Result<(), Error> {
        if let FormData::Map(ref mut map) = self {
            match more_keys.next() {
                None => {
                    map.insert(key, value);
                }
                Some(next_match) => {
                    let next_key = next_match.get(1).unwrap().as_str();
                    if next_key.len() == 0 {
                        if map.get(&key).is_none() {
                            map.insert(
                                key.to_string(),
                                Self::Arr(Vec::new()),
                            );
                        }
                        map.get_mut(&key).unwrap().push(more_keys, value)?
                    } else {
                        if map.get(&key).is_none() {
                            map.insert(
                                key.to_string(),
                                Self::Map(HashMap::new()),
                            );
                        }
                        map.get_mut(&key).unwrap().insert(
                            next_key.to_string(),
                            more_keys,
                            value,
                        )?
                    }
                }
            }
            Ok(())
        } else {
            Err(Error::invalid_input("self is not a Map variant"))
        }
    }

    // Expect self to be an Arr and value to be a Leaf.
    // Depending on more_keys.next():
    // - None => push value on self
    // - "" => recurse to push() to the Arr last in self
    // - => recurse to insert() in the Map last in self
    fn push(
        &mut self,
        mut more_keys: Peekable<CaptureMatches>,
        value: Self,
    ) -> Result<(), Error> {
        if let FormData::Arr(ref mut arr) = self {
            match more_keys.next() {
                None => arr.push(value),
                Some(next_match) => {
                    let next_key = next_match.get(1).unwrap().as_str();
                    if next_key.len() == 0 {
                        if arr.is_empty() {
                            arr.push(Self::Arr(Vec::new()));
                        }
                        arr.last_mut().unwrap().push(more_keys, value)?
                    } else {
                        if arr.is_empty() {
                            arr.push(Self::Map(HashMap::new()));
                        }
                        arr.last_mut().unwrap().insert(
                            next_key.to_string(),
                            more_keys,
                            value,
                        )?
                    }
                }
            }
            Ok(())
        } else {
            Err(Error::invalid_input("self is not an Arr variant"))
        }
    }

    // vals is [(<URL or body parameter name>, <URL-decoded string value>)].
    // The parameter name should be e.g. "foo[bar][]" indicating that the
    // value is an element in an array that is a value with key "bar" in a
    // map that is the value with key "foo" in the returned FormData::Map.
    fn parse(vals: Vec<(String, String)>) -> Result<Self, Error> {
        ::lazy_static::lazy_static! {
            static ref BRACKETS: Regex = Regex::new(r"\[([^]]*)\]").unwrap();
        }
        let mut result = FormData::Map(HashMap::new());
        for (raw_key, raw_val) in vals {
            let val = Self::Leaf(raw_val);
            let mut nested = BRACKETS.captures_iter(&raw_key).peekable();
            let key = if let Some(mtch) = nested.peek() {
                &raw_key[0..mtch.get(0).unwrap().start()]
            } else {
                &raw_key
            };
            result.insert(key.to_string(), nested, val)?;
        }
        Ok(result)
    }
}

impl Serialize for FormData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::{SerializeMap, SerializeSeq};
        match self {
            Self::Arr(a) => {
                let mut seq = serializer.serialize_seq(Some(a.len()))?;
                for e in a {
                    seq.serialize_element(e)?;
                }
                seq.end()
            }
            Self::Map(m) => {
                let mut map = serializer.serialize_map(Some(m.len()))?;
                for (k, v) in m {
                    map.serialize_entry(k, v)?;
                }
                map.end()
            }
            Self::Leaf(l) => serializer.serialize_str(l),
        }
    }
}

/// Normalize an HTTP path from e.g. `"/a/<`...`>/b/<`...`>/c"` to a pair <br>
/// `( String::from("/a/<p1>/b/<p2>/c"), 2 /* the number of params */ )`
///
fn normalize_route(route: &str) -> (String, usize) {
    let mut result: (String, usize) = (String::new(), 0);
    let mut last = 0;
    for mat in PATH_PARAMS.find_iter(route) {
        result.0.extend(route[last..mat.start()].chars());
        result.1 += 1;
        result.0.extend(format!("<p{}>", result.1).chars());
        last = mat.end();
    }
    if last < route.len() {
        result.0.extend(route[last..route.len()].chars());
    }
    result
}

// - - Config helpers  - - - - - - - - - - - - - - - - - - - - - - - - - - - -

impl Parse for Config {
    fn parse(stream: ParseStream) -> ::syn::Result<Self> {
        let mut plug_ins = HashMap::new();
        let mut app_config = HashMap::new();
        let mut authorizers = Authorizers::new();
        let mut parsed_routes = Vec::new();
        let mut not_found = None;
        for item in stream
            .parse_terminated::<ConfigItem, token::Comma>(ConfigItem::parse)?
        {
            match item.level_1 {
                ConfigItemId::AppConfig => {
                    item.get_app_conf(&mut app_config)?
                }
                ConfigItemId::Authorize => {
                    item.get_authorizer(&mut authorizers)?
                }
                ConfigItemId::NotFound => {
                    item.get_not_found(&mut not_found)?
                }
                ConfigItemId::PlugIn => item.get_plug_in(&mut plug_ins)?,
                ConfigItemId::Routes => {
                    item.get_routes(&mut parsed_routes)?
                }
            }
        }
        if !plug_ins.contains_key("DbConn") {
            plug_ins.insert(
                "DbConn".to_string(),
                (
                    parse_quote!(::vicocomo::NullConn),
                    parse_quote!(::vicocomo::NullConn),
                ),
            );
        }
        if !plug_ins.contains_key("Session") {
            plug_ins.insert(
                "Session".to_string(),
                (
                    parse_quote!(::vicocomo::NullSession),
                    parse_quote!(::vicocomo::NullSession),
                ),
            );
        }
        if !plug_ins.contains_key("TemplEng") {
            plug_ins.insert(
                "TemplEng".to_string(),
                (
                    parse_quote!(::vicocomo::NullTemplEng),
                    parse_quote!(::vicocomo::NullTemplEng),
                ),
            );
        }
        let contr_prefix: Path = match app_config.get("controller_prefix") {
            Some(val) => val.get_path()?,
            None => {
                let path: Path = parse_quote!(crate::controllers);
                app_config.insert(
                    "controller_prefix".to_string(),
                    ConfigAttrVal::Path(path.clone()),
                );
                path
            }
        };
        let role_enum: Option<Type> = {
            enum Result {
                False,
                Deflt,
                Given,
            }
            match match app_config.get("role_enum") {
                Some(val) => match val {
                    ConfigAttrVal::Literal(_) => {
                        if val.get_bool()? {
                            Result::Deflt
                        } else {
                            Result::Given
                        }
                    }
                    _ => Result::Given,
                },
                None => {
                    if app_config.contains_key("role_variants") {
                        Result::Deflt
                    } else {
                        Result::False
                    }
                }
            } {
                Result::False => {
                    app_config.insert(
                        "role_enum".to_string(),
                        ConfigAttrVal::Literal(parse_quote!(false)),
                    );
                    None
                }
                Result::Deflt => {
                    app_config.insert(
                        "role_enum".to_string(),
                        ConfigAttrVal::Path(parse_quote!(
                            crate::models::UserRole
                        )),
                    );
                    Some(parse_quote!(crate::models::UserRole))
                }
                Result::Given => {
                    let p =
                        app_config.get("role_enum").unwrap().get_path()?;
                    Some(parse_quote!(#p))
                }
            }
        };
        if role_enum.is_some() {
            let mut roles = match app_config.get("role_variants") {
                Some(v) => v.get_array_strings()?,
                None => Vec::new(),
            };
            for predefined in &["Superuser"] {
                let predef = predefined.to_string();
                if !roles.contains(&predef) {
                    roles.push(predef);
                }
            }
            authorizers.sanitize(roles.as_slice())?;
            match app_config.get("unauthorized_route") {
                Some(r) => {
                    r.get_str()?;
                }
                None => {
                    app_config.insert(
                        "unauthorized_route".to_string(),
                        ConfigAttrVal::Literal(parse_quote!("/")),
                    );
                }
            }
        }
        let mut routes: HashMap<Path, Vec<Handler>> = HashMap::new();
        for (mut contr_path, mut handler) in parsed_routes.drain(..) {
            match contr_path.get_ident() {
                Some(id) => {
                    contr_path.segments = parse_quote!(#contr_prefix::#id);
                }
                None => (),
            }
            if role_enum.is_some() {
                handler.authorize(
                    authorizers.get(handler.http_method)?,
                    role_enum.as_ref().unwrap(),
                )?;
            }
            match routes.get_mut(&contr_path) {
                Some(hands) => hands.push(handler),
                None => {
                    routes.insert(contr_path, vec![handler]);
                }
            }
        }
        Ok(Self {
            plug_ins,
            app_config,
            routes,
            not_found,
        })
    }
}

impl Handler {
    fn authorize(
        &mut self,
        authorizers: &[Authorizer],
        role_enum: &Type,
    ) -> ::syn::Result<()> {
        for auth in authorizers {
            if auth.pattern.is_match(&self.route) {
                if auth.roles == vec!["Public".to_string()] {
                    return Ok(());
                }
                let mut allow: Vec<Expr> = auth
                    .roles
                    .iter()
                    .map(|s| {
                        let variant = format_ident!("{}", s);
                        parse_quote!(#role_enum::#variant)
                    })
                    .collect();
                if !auth.roles.contains(&"Superuser".to_string()) {
                    allow.push(parse_quote!(#role_enum::Superuser));
                }
                self.authorized = Some(Authorized {
                    allow,
                    filter: auth.filter,
                });
                return Ok(());
            }
        }
        Err(syn_error(&format!(
            "no authorization for route {}",
            self.route
        )))
    }
}

#[derive(Clone, Debug)]
struct ConfigItem {
    level_1: ConfigItemId,
    value: Option<ConfigAttrVal>,
    level_2: Vec<Level2>,
}

#[derive(Clone, Copy, Debug)]
enum ConfigItemId {
    AppConfig,
    Authorize,
    NotFound,
    PlugIn,
    Routes,
}

impl ConfigItem {
    // expects level_1 to be AppConfig
    fn get_app_conf(
        &self,
        app_config: &mut HashMap<String, ConfigAttrVal>,
    ) -> ::syn::Result<()> {
        match self.level_2.first() {
            Some(l2) => {
                for attr in &l2.attrs {
                    app_config.insert(attr.id.to_string(), attr.val.clone());
                }
            }
            _ => (),
        }
        Ok(())
    }

    // expects level_1 to be Authorize
    fn get_authorizer(
        &self,
        authorizers: &mut Authorizers,
    ) -> ::syn::Result<()> {
        let mut pat_str = self
            .value
            .as_ref()
            .ok_or_else(|| {
                syn::Error::new(
                    ::proc_macro2::Span::call_site(),
                    "missing authorize pattern",
                )
            })?
            .get_str()?;
        // ensure slash at beginning
        if pat_str.get(0..1).map(|c| c != "/").unwrap_or(true) {
            pat_str.insert(0, '/');
        }
        let wild = pat_str.len() >= 2
            && pat_str
                .get((pat_str.len() - 2)..)
                .map(|s| s == "/*")
                .unwrap_or(false);
        let pat_tail;
        if wild {
            pat_str.truncate(pat_str.len() - 2);
            pat_tail = r"(/.*)?$";
        } else {
            pat_tail = r"$";
        }
        pat_str += pat_tail;
        pat_str = PATH_PARAMS.replace_all(&pat_str, r"([^/]+)").to_string();
        let pattern =
            Regex::new(&pat_str).map_err(|e| syn_error(&e.to_string()))?;
        let priority = 2 * (pat_str.len() - pat_tail.len()) + wild as usize;
        for l2 in self.level_2.as_slice() {
            if l2.id.is_some() {
                let method =
                    Self::ident_to_http_method(l2.id.as_ref().unwrap())?;
                for attr in &l2.attrs {
                    let mut filter = false;
                    let attr_id_str = attr.id.to_string();
                    match attr_id_str.as_str() {
                        "allow" => (),
                        "filter" => filter = true,
                        _ => {
                            return Err(syn_error(&format!(
                                "unknown authorization attribute: {}",
                                attr_id_str,
                            )));
                        }
                    }
                    authorizers.insert(
                        method,
                        Authorizer {
                            priority,
                            pattern: pattern.clone(),
                            roles: attr.val.get_array_strings()?,
                            filter,
                        },
                    );
                }
            } else {
                for attr in &l2.attrs {
                    authorizers.insert(
                        Self::ident_to_http_method(&attr.id)?,
                        Authorizer {
                            priority,
                            pattern: pattern.clone(),
                            roles: attr.val.get_array_strings()?,
                            filter: false,
                        },
                    );
                }
            }
        }
        Ok(())
    }

    // expects level_1 to be NotFound
    fn get_not_found(
        &self,
        not_found: &mut Option<(Path, Ident)>,
    ) -> ::syn::Result<()> {
        Ok(*not_found = Some((
            self.value
                .as_ref()
                .ok_or_else(|| syn_error("missing not_found controller Path"))
                .and_then(|v| v.get_path())?,
            self.level_2
                .first()
                .and_then(|l2| l2.id.clone())
                .ok_or_else(|| {
                    syn_error("missing not_found function Ident")
                })?,
        )))
    }

    // expects level_1 to be PlugIn
    fn get_plug_in(
        &self,
        plug_ins: &mut HashMap<String, (Type, Expr)>,
    ) -> ::syn::Result<()> {
        let id = self
            .value
            .as_ref()
            .ok_or_else(|| syn_error("missing plug in identifier"))
            .and_then(|path| path.get_ident().map(|id| id.to_string()))?;
        let l2 = self
            .level_2
            .first()
            .ok_or_else(|| syn_error("missing plug in attributes"))?;
        plug_ins.insert(
            id,
            l2.attrs
                .iter()
                .find(|ci| ci.id.to_string() == "def")
                .ok_or_else(|| syn_error("missing plug in attribute 'def'"))?
                .val
                .get_type_expr()?,
        );
        Ok(())
    }

    // expects level_1 to be Routes
    fn get_routes(
        &self,
        routes: &mut Vec<(Path, Handler)>,
    ) -> ::syn::Result<()> {
        use ::case::CaseExt;
        let contr_path = self
            .value
            .as_ref()
            .ok_or_else(|| syn_error("missing route controller path"))
            .and_then(|v| v.get_path())?;
        let contr_id = &contr_path.segments.last().unwrap().ident.clone();
        let contr_id_snake = contr_id.to_string().to_snake();
        for l2 in &self.level_2 {
            let contr_method: Ident = l2
                .id
                .clone()
                .ok_or_else(|| syn_error("missing route handler function"))?;
            let mut http_method = HttpMethod::Get;
            let mut route_str: Option<&str> = None;
            match contr_method.to_string().as_str() {
                "new_form" => route_str = Some("new"),
                "copy_form" => route_str = Some("<id>/copy"),
                "create" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("");
                }
                "ensure" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("ensure");
                }
                "index" => route_str = Some(""),
                "show" => route_str = Some("<id>"),
                "edit_form" => route_str = Some("<id>/edit"),
                "patch" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("<id>");
                }
                "replace" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("<id>/replace");
                }
                "delete" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("<id>/delete");
                }
                _ => (),
            }
            let mut route = route_str.map(|s| s.to_string());
            for attr in &l2.attrs {
                let attr_nam = attr.id.to_string();
                match attr_nam.as_str() {
                    "http_method" => {
                        http_method = attr.val.get_ident().and_then(|i| {
                            HttpMethod::try_from(i.to_string().as_str())
                                .map_err(|e| syn_error(&e.to_string()))
                        })?;
                    }
                    "path" => {
                        let mut s = attr.val.get_str()?;
                        if 1 < s.len() && s.chars().last() == Some('/') {
                            s.remove(s.len() - 1);
                        }
                        route = Some(s);
                    }
                    _ => {
                        return Err(syn_error(&format!(
                            "unknown handler attribute {}",
                            &attr_nam,
                        )));
                    }
                }
            }
            match route {
                Some(ref mut s) if s.chars().nth(0) != Some('/') => {
                    if !s.is_empty() {
                        s.insert(0, '/');
                    }
                    s.insert_str(0, &contr_id_snake);
                    s.insert(0, '/');
                }
                Some(_) => (),
                None => return Err(syn_error("missing path")),
            }
            let (route, route_par_count) =
                normalize_route(route.as_ref().unwrap());
            routes.push((
                contr_path.clone(),
                Handler {
                    http_method,
                    route,
                    route_par_count,
                    authorized: None,
                    contr_method,
                },
            ));
        }
        Ok(())
    }

    fn ident_to_http_method(id: &Ident) -> ::syn::Result<HttpMethod> {
        HttpMethod::try_from(id.to_string().as_str())
            .map_err(|e| syn_error(&e.to_string()))
    }
}

impl Parse for ConfigItem {
    fn parse(stream: ParseStream) -> ::syn::Result<Self> {
        let level_1: ConfigItemId = {
            let id = stream.parse::<Ident>()?.to_string();
            match id.as_str() {
                "app_config" => ConfigItemId::AppConfig,
                "authorize" => ConfigItemId::Authorize,
                "not_found" => ConfigItemId::NotFound,
                "plug_in" => ConfigItemId::PlugIn,
                "route" => ConfigItemId::Routes,
                _ => {
                    return Err(syn_error(&format!(
                        "'{}' cannot start a Config item",
                        &id
                    )));
                }
            }
        };
        let value: Option<ConfigAttrVal> = if stream.peek(token::Paren) {
            let content;
            parenthesized!(content in stream);
            if content.is_empty() {
                None
            } else {
                Some(content.parse()?)
            }
        } else {
            None
        };
        let mut level_2: Vec<Level2> = Vec::new();
        if stream.peek(token::Brace) && {
            let fork = stream.fork();
            let content;
            braced!(content in fork);
            content.peek(Ident) && content.peek2(token::Colon)
        } {
            // only lev 3
            level_2.push(Level2 {
                id: None,
                attrs: get_config_attrs(stream)?,
            });
        } else {
            let content;
            braced!(content in stream);
            level_2 = content
                .parse_terminated::<Level2, token::Comma>(Level2::parse)?
                .into_iter()
                .collect();
        }
        Ok(Self {
            level_1,
            value,
            level_2,
        })
    }
}

impl Parse for ConfigAttrVal {
    fn parse(stream: ParseStream) -> ::syn::Result<Self> {
        if stream.peek(token::Paren) {
            let content;
            parenthesized!(content in stream);
            let ty: Type = content.parse()?;
            content.parse::<token::Comma>()?;
            let expr: Expr = content.parse()?;
            let _ = content.parse::<token::Comma>();
            return Ok(Self::TypeExpr(ty, expr));
        }
        let expr: Expr = stream.parse()?;
        match &expr {
            Expr::Array(a) => {
                let mut id_vec = Vec::new();
                for elem in &a.elems {
                    match elem {
                        Expr::Path(ep) if ep.path.get_ident().is_some() => {
                            id_vec.push(ep.path.get_ident().unwrap().clone());
                        }
                        _ => {
                            return Err(syn_error(&format!(
                                "{} is not an identifier",
                                tokens_to_string(&elem),
                            )));
                        }
                    }
                }
                Ok(Self::Array(id_vec))
            }
            Expr::Lit(_) => Ok(Self::Literal(expr)),
            Expr::Path(p) => Ok(p
                .path
                .get_ident()
                .map(|i| Self::Ident(i.clone()))
                .unwrap_or_else(|| Self::Path(p.path.clone()))),
            _ => Err(syn_error(&format!(
                "cannot handle attribute value '{}'",
                tokens_to_string(&expr.clone()),
            ))),
        }
    }
}

#[derive(Clone, Debug)]
struct Authorizer {
    priority: usize,
    pattern: Regex,
    roles: Vec<String>,
    filter: bool,
}

impl Eq for Authorizer {}

impl Ord for Authorizer {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority) // sic!
    }
}

impl PartialEq for Authorizer {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl PartialOrd for Authorizer {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

struct Authorizers(HashMap<HttpMethod, Vec<Authorizer>>);

impl Authorizers {
    fn new() -> Self {
        Self(HashMap::new())
    }

    fn get(&self, method: HttpMethod) -> ::syn::Result<&[Authorizer]> {
        Ok(self
            .0
            .get(&method)
            .ok_or_else(|| {
                syn_error(&format!(
                    "no authorizations for HTTP method {}",
                    method.to_string()
                ))
            })?
            .as_slice())
    }

    fn insert(&mut self, method: HttpMethod, authorizer: Authorizer) {
        match self.0.get_mut(&method) {
            Some(auths) => auths.push(authorizer),
            None => {
                self.0.insert(method, vec![authorizer]);
            }
        }
    }

    // Resolve all pseudo roles except `Public`, which is handled later.
    // Sort.
    fn sanitize(&mut self, defined_roles: &[String]) -> ::syn::Result<()> {
        let enabled: Vec<String> = defined_roles
            .iter()
            .filter(|r| r.as_str() != "Disabled")
            .map(|r| r.clone())
            .collect();
        for (_, auths) in &mut self.0 {
            for auth in auths.iter_mut() {
                for role in &auth.roles {
                    match role.as_str() {
                        "Authenticated" => {
                            Self::assert_single(
                                &role,
                                auth.roles.as_slice(),
                            )?;
                            auth.roles = defined_roles.to_vec();
                            break;
                        }
                        "Enabled" => {
                            Self::assert_single(
                                &role,
                                auth.roles.as_slice(),
                            )?;
                            auth.roles = enabled.clone();
                            break;
                        }
                        "Public" => {
                            Self::assert_single(
                                &role,
                                auth.roles.as_slice(),
                            )?;
                            break;
                        }
                        _ if defined_roles.contains(&role) => (),
                        _ => {
                            return Err(syn_error(&format!(
                                "{} is not a role",
                                role
                            )));
                        }
                    }
                }
            }
            auths.sort();
        }
        Ok(())
    }

    fn assert_single(role: &str, roles: &[String]) -> ::syn::Result<()> {
        if roles.len() == 1 {
            return Ok(());
        }
        Err(syn_error(&format!("{} should be the only role", role)))
    }
}

#[derive(Clone, Debug)]
struct Level2 {
    id: Option<Ident>,
    attrs: Vec<ConfigAttr>,
}

impl Parse for Level2 {
    fn parse(stream: ParseStream) -> ::syn::Result<Self> {
        Ok(Self {
            id: stream.parse()?,
            attrs: get_config_attrs(stream)?,
        })
    }
}

fn get_config_attrs(stream: ParseStream) -> ::syn::Result<Vec<ConfigAttr>> {
    Ok(if stream.peek(token::Brace) {
        let content;
        braced!(content in stream);
        content
            .parse_terminated::<ConfigAttr, token::Comma>(ConfigAttr::parse)?
            .into_iter()
            .collect()
    } else {
        Vec::new()
    })
}

#[derive(Clone, Debug)]
struct ConfigAttr {
    id: Ident,
    val: ConfigAttrVal,
}

impl Parse for ConfigAttr {
    fn parse(stream: ParseStream) -> ::syn::Result<Self> {
        let id: Ident = stream.parse()?;
        stream.parse::<token::Colon>()?;
        Ok(Self {
            id,
            val: stream.parse()?,
        })
    }
}

fn syn_error(e: &str) -> ::syn::Error {
    ::syn::Error::new(::proc_macro2::Span::call_site(), e)
}

#[cfg(test)]
mod tests {
    use super::*;
    use ::serde_json::json;

    #[test]
    fn test_formdata() {
        assert_eq!(
            ::serde_json::to_value(
                FormData::parse(
                    vec![
                        ("smpl", "1"),
                        ("arr[]", "2"),
                        ("arr[]", "3"),
                        ("map[a]", "4"),
                        ("map[b]", "5"),
                        ("deep[c][]", "6"),
                        ("deep[c][]", "7"),
                        ("deep[d]", "8"),
                        ("mtrx[][]", "9"),
                    ]
                    .iter()
                    .map(|(k, v)| (k.to_string(), v.to_string()))
                    .collect(),
                )
                .unwrap(),
            )
            .unwrap(),
            json!({
                "smpl": "1",
                "arr":  ["2", "3"],
                "map":  { "a": "4", "b": "5" },
                "deep": { "c": ["6", "7"], "d": "8" },
                "mtrx": [["9"]],
            }),
        );
    }
}
