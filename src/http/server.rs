//! Structs and traits implemented by HTTP server adapter and used by web
//! application developers.
//!

use crate::Error;
use core::{
    convert::TryFrom,
    fmt::{self, Display, Formatter},
};
use quote::format_ident;
use serde::{de::DeserializeOwned, Serialize};
use serde_json::Value as JsonValue;
use std::{cmp::Ordering, collections::HashMap};
use syn::{
    braced, bracketed, parenthesized,
    parse::{Parse, ParseStream},
    parse_quote, token, Expr, Ident, LitBool, LitChar, LitFloat, LitInt,
    LitStr, Path, Type,
};
use vicocomo_derive_utils::*;

// --- for web application developers ----------------------------------------

/// The return type of [`HttpServerIf::app_config()`
/// ](struct.HttpServerIf#method.app_config).
///
#[derive(Clone, Debug)]
pub enum AppConfigVal {
    Arr(Vec<AppConfigVal>),
    Bool(bool),
    Char(char),
    Float(f64),
    Ident(String),
    Int(i64),
    Path(String),
    Str(String),
}

macro_rules! get_app_config_val_variant {
    ($name:ident ( $variant:ident ) -> $ret_type:ty) => {
        /// Return the contained value if the eponymous variant or `None`
        pub fn $name(&self) -> Option<$ret_type> {
            if let Self::$variant(v) = self {
                Some(v.clone())
            } else {
                None
            }
        }
    };
}

impl AppConfigVal {
    get_app_config_val_variant! { arr(Arr) -> Vec<AppConfigVal> }
    get_app_config_val_variant! { bool(Bool) -> bool }
    get_app_config_val_variant! { char(Char) -> char }
    get_app_config_val_variant! { float(Float) -> f64 }
    get_app_config_val_variant! { ident(Ident) -> String }
    get_app_config_val_variant! { int(Int) -> i64 }
    get_app_config_val_variant! { path(Path) -> String }
    get_app_config_val_variant! { str(Str) -> String }
}

/// The Vicocomo interface to an HTTP server. Parameter to the controller
/// methods called by the code generated by a server specific [`config`
/// ](struct.Config.html) macro.
///
#[derive(Clone, Copy)]
pub struct HttpServerIf<'a>(&'a dyn HttpServer);

impl<'a> HttpServerIf<'a> {
    /// Create an interface to the `server`. *Not to be used by web
    /// application developers, web server adapters only.*
    ///
    pub fn new(server: &'a impl HttpServer) -> Self {
        Self(server)
    }

    /// Get an attribute value as set by the HTTP server's `config` macro's
    /// [`app_config`](struct.Config.html#level-1-app_config) entry.
    ///
    /// Note that an implementation is free to add its own HTTP server
    /// specific attributes.
    ///
    /// Literal values are represented in the obvious way. Identifiers and
    /// rust paths are converted to strings. Arrays are represented by `Vec`.
    /// Plugins are not expected as `app_config` values and shall return
    /// `None` even if defined.
    ///
    /// Note that entries that have default values are accessible here even
    /// if they are not defined in the `config` macro.
    ///
    pub fn app_config(self, id: &str) -> Option<AppConfigVal> {
        self.0.app_config(id)
    }

    /// The parameter values in the URL (get) or body (post) as a
    /// `serde_json::Value`.
    ///
    /// The parameters may be structured Ã  la PHP:
    // No doc test, but see the unit test test_formdata()
    /// ```text
    /// smpl=1&arr[]=2&arr[]=3&map[a]=4&map[b]=5&deep[c][]=6&deep[c][]=7&deep[d]=8&mtrx[][]=9
    /// -> json!({
    ///     "smpl": "1",
    ///     "arr":  ["2", "3"],
    ///     "map":  { "a": "4", "b": "5" },
    ///     "deep": { "c": ["6", "7"], "d": "8" },
    ///     "mtrx": [["9"]],
    /// })
    /// ```
    /// Note that all leaf values are strings.
    ///
    pub fn param_json(&self) -> Result<JsonValue, Error> {
        FormData::parse(self.0.param_vals()).and_then(|fd| {
            serde_json::to_value(&fd)
                .map_err(|e| Error::invalid_input(&e.to_string()))
        })
    }

    /// The value of the parameter with `name` in the URL (get) or body (post)
    /// deserialized from a URL-decoded string.  For structured parameters,
    /// use [`param_json()`](#method.param_json)
    ///
    pub fn param_val<T>(self, name: &str) -> Option<T>
    where
        T: DeserializeOwned,
    {
        self.0
            .param_val(name)
            .and_then(|s| serde_json::from_str(&s).ok())
    }

    /// The path part of the request, without scheme, host, or parameters.
    /// The [`url_root`](struct.Config.html#url_root) <b>is stripped</b> from
    /// the path.
    ///
    pub fn req_path(self) -> String {
        self.strip_url_root(&self.0.req_path())
    }

    /// If registered as `"a/<p1>/<p2>"` and the HTTP path of the request is
    /// `"a/42/Hello"`, and a local variable `srv: HttpServerIf`, the
    /// following holds:
    /// ```text
    /// assert!(srv.req_route_par_val::<i32>("p1").unwrap() == 42);
    /// assert!(srv.req_route_par_val::<String>("p2").unwrap() == "Hello");
    /// ```
    ///
    pub fn req_route_par_val<T>(self, par: &str) -> Option<T>
    where
        T: DeserializeOwned,
    {
        self.0.req_route_par_val(par).and_then(|s| {
            serde_json::from_str(&s)
                .or_else(|_| {
                    serde_json::from_str(&("\"".to_string() + &s + "\""))
                })
                .ok()
        })
    }

    // TODO: should return an iterator
    //
    /// If registered as `"a/<p1>/<p2>"` and the HTTP path of the request is
    /// `"a/42/Hello"`, this will collect as
    /// ```text
    /// vec![
    ///     (String::from("p1"), String::from("42")),
    ///     (String::from("p2"), String::from("Hello")),
    /// ]
    /// ```
    pub fn req_route_par_vals(self) -> Vec<(String, String)> {
        self.0.req_route_par_vals()
    }

    /// The body of the request.
    ///
    pub fn req_body(self) -> String {
        self.0.req_body()
    }

    /// The requested HTTP URL, including preferably scheme and host, always
    /// path, and, if applicable, query. The [`url_root`
    /// ](struct.Config.html#url_root) <b>is not stripped</b> from the path.
    ///
    pub fn req_url(self) -> String {
        self.0.req_url()
    }

    /// Set the body of the response.
    ///
    /// It is OK to call any number of the `resp_*` methods and to call the
    /// same method more than once. The response is as defined in the last
    /// call.
    ///
    pub fn resp_body(self, txt: &str) {
        self.0.resp_body(txt)
    }

    /// Generate an internal server error response, replacing the body.
    ///
    /// It is OK to call any number of the `resp_*` methods and to call the
    /// same method more than once. The response is as defined in the last
    /// call.
    ///
    pub fn resp_error(self, err: Option<&Error>) {
        self.0.resp_error(err)
    }

    /// Serve a static file, ignoring the body.
    ///
    /// `file_path` is the absolute path of the file if it starts with '`/`',
    /// or relative to the [`file_root`](struct.Config.html#file_root) if it
    /// does not.
    ///
    /// If [`strip_mtime`](struct.Config.html#strip_mtime) is `true` and the
    /// `file_path` matches `[^/]+(-\d{10})(\.[^/.]+)?$`, the `-\d{10}` group
    /// is removed.
    ///
    /// It is OK to call any number of the `resp_*` methods and to call the
    /// same method more than once. The response is as defined in the last
    /// call.
    ///
    pub fn resp_file(self, file_path: &str) {
        self.0.resp_file(&self.prepend_file_root(file_path))
    }

    /// Generate an OK response, using the body.
    ///
    /// It is OK to call any number of the `resp_*` methods and to call the
    /// same method more than once. The response is as defined in the last
    /// call.
    ///
    pub fn resp_ok(self) {
        self.0.resp_ok()
    }

    /// Generate a redirect response, ignoring the body.
    ///
    /// If `url` starts with `/` the [`url_root`](struct.Config.html#url_root)
    /// is prepended.
    ///
    /// It is OK to call any number of the `resp_*` methods and to call the
    /// same method more than once. The response is as defined in the last
    /// call.
    ///
    pub fn resp_redirect(self, url: &str) {
        self.0.resp_redirect(&self.prepend_url_root(url))
    }

    /// Clear the entire session.
    ///
    pub fn session_clear(self) {
        self.0.session_clear();
    }

    /// Return the session value for `key` as `T`.
    ///
    /// If there is no current value for `key`, or  the current value for
    /// `key` is not a `T`,`None` is returned.
    ///
    pub fn session_get<T>(self, key: &str) -> Option<T>
    where
        T: DeserializeOwned,
    {
        self.0
            .session_get(key)
            .and_then(|s| serde_json::from_str(&s).ok())
    }

    /// Remove the `key`-value pair.
    ///
    pub fn session_remove(self, key: &str) {
        self.0.session_remove(key)
    }

    /// Set a `value` for `key`.
    ///
    /// Returns an error if serializing fails.
    ///
    pub fn session_set<T>(self, key: &str, value: &T) -> Result<(), Error>
    where
        T: Serialize,
    {
        self.0.session_set(
            key,
            &serde_json::to_string(value)
                .map_err(|e| Error::other(&e.to_string()))?,
        )
    }

    /// ### For HTTP server adapter developers only
    ///
    /// Handle files routed by the `config` macro's [`route_static`
    /// ](#level-1-route_static) entries. If the `app_config` attribute
    /// [`strip_mtime`](struct.Config.html#strip_mtime) is `true`, this is
    /// needed to strip the mtime. If not, the use of this function is
    /// optional.
    ///
    /// On entry, [`req_path()`](#method.req_path) is required to have the
    /// form `"<url_path>/<file>"` where `<url_path>` is the first string in
    /// a [`route_static`](#level-1-route_static) entry in the `config` macro.
    ///
    /// First, tries to find  a file system directory by [`url_path_to_dir()`
    /// ](#method#url_path_to_dir). If not found, [`resp_error()`
    /// ](#method.resp_error).
    ///
    /// Then, appends `file` to the directory and [`resp_file()`
    /// ](#method.resp_file).
    ///
    pub fn static_file_handler(&self) {
        lazy_static::lazy_static! {
            static ref SPLIT: Regex = regex::Regex::new(r"/").unwrap();
        }
        let (url_path, file) = {
            let orig_path = self.req_path();
            let mut pieces: Vec<&str> = SPLIT.split(&orig_path).collect();
            let file = pieces.pop().unwrap();
            (pieces.join("/").to_string(), file.to_string())
        };
        self.url_path_to_dir(&url_path)
            .map(|dir| self.resp_file(&(dir + &file)))
            .unwrap_or_else(|| {
                self.resp_error(Some(&Error::this_cannot_happen(
                    "static-route-not-found",
                )));
            });
    }

    /// Map URL to file directory for serving static files as defined by the
    /// `config` macro's [`route_static`](#level-1-route_static) entries.
    ///
    /// `url_path` is the <b>absolute</b> URL, without [`url_root`
    /// ](struct.Config.html#url_root). A missing leading slash is inserted.
    ///
    /// The returned file system path is guaranteed to end with a slash. If it
    /// starts with a slash it is absolute, if not it is relative to
    /// [`file_root`](struct.Config.html#file_root).
    ///
    pub fn url_path_to_dir(&self, url_path: &str) -> Option<String> {
        use crate::fix_slashes;
        let url_path = fix_slashes(url_path, 1, -1);
        self.0
            .url_path_to_dir(&self.prepend_url_root(&url_path))
            .as_ref()
            .map(|dir| fix_slashes(&self.strip_file_root(dir), 0, 1))
    }

    // --- private -----------------------------------------------------------

    /// prepend file_root if not starts with '/', strip mtime if strip_mtime
    pub(crate) fn prepend_file_root(&self, file_path: &str) -> String {
        lazy_static::lazy_static! {
            static ref MTIME: Regex =
                Regex::new(r"([^/]+)-\d{10}(\.[^/.]+)?$").unwrap();
        }
        let stripped =
            if self.0.app_config("strip_mtime").unwrap().bool().unwrap()
                && MTIME.is_match(file_path)
            {
                MTIME.replace(file_path, "$1$2")
            } else {
                file_path.into()
            };
        if stripped.starts_with('/') {
            stripped.to_string()
        } else {
            self.0.app_config("file_root").unwrap().str().unwrap() + &stripped
        }
    }

    // prepend url_root if starts with '/'
    pub(crate) fn prepend_url_root(&self, url_path: &str) -> String {
        if url_path.starts_with('/') {
            self.0.app_config("url_root").unwrap().str().unwrap() + url_path
        } else {
            url_path.to_string()
        }
    }

    // strip file_root if at beginning
    pub(crate) fn strip_file_root(&self, file_path: &str) -> String {
        file_path
            .strip_prefix(
                &self.0.app_config("file_root").unwrap().str().unwrap(),
            )
            .map(|dir| dir.to_string())
            .unwrap_or_else(|| file_path.to_string())
    }

    // strip url_root if at beginning
    pub(crate) fn strip_url_root(&self, url_path: &str) -> String {
        url_path
            .strip_prefix(
                &self.0.app_config("url_root").unwrap().str().unwrap(),
            )
            .map(|url| url.to_string())
            .unwrap_or_else(|| url_path.to_string())
    }
}

/// The Vicocomo interface to a template rendering engine.  Parameter to the
/// controller methods called by the code generated by a server specific
/// [`config`](struct.Config.html) macro.
///
#[derive(Clone, Copy)]
pub struct TemplEngIf<'a>(&'a dyn TemplEng);

impl<'a> TemplEngIf<'a> {
    /// Create from a `TemplEng`. Intended for web server adapter developers.
    ///
    pub fn new(eng: &'a impl TemplEng) -> Self {
        Self(eng)
    }

    /// Render, filling out `tmpl` with `data`.
    ///
    pub fn render(
        self,
        tmpl: &str,
        data: &impl Serialize,
    ) -> Result<String, Error> {
        self.0.render(
            tmpl,
            &::serde_json::to_value(data)
                .map_err(|e| Error::render(&e.to_string()))?,
        )
    }
}

// --- for web application and server adapter developers ---------------------

// - - Config documentation  - - - - - - - - - - - - - - - - - - - - - - - - -

/// A syntax tree node for configuring an HTTP server.  Intended for use in a
/// server specific `config` macro.
///
/// <b>Web application developers:</b> The HTTP server `vicocomo` adapter
/// crate defines a macro `config` that accepts input as documented here.
/// Knowledge of the structure and inner workings of `Config` is *not*
/// necessary for developing an application using that macro.
///
/// <b>HTTP server adapter developers:</b> It is your responsibility to ensure
/// that this documentation is implemented by your adapter! There is an
/// implementation for [`actix-web`](https://crates.io/crates/actix-web) [here
/// ](../../vicocomo_actix/macro.config.html).
///
// TODO: named routes and url_for().
//
/// # Macro input syntax
///
/// A HTTP server adapter's `config` macro takes input of the form
/// ```text
/// level_1(value) { level_2 { level_3: value, ... }, ... }, ...
/// ```
/// where `level_1`, `level_2`, and `level_3` are identifiers while the
/// `value`s are
/// - *an identifer*,
/// - *a bool, char, float, integer, or string literal*,
/// - *a Rust path*,
/// - `[` *any of the above*`, `... (more of the same)` ]`, or
/// - `(` *a type*`, `*an expression*` )`,
///
/// The level 1 `value` and its parentheses are optional as well as the braced
/// groups and braces if empty. One `level_3` may be present without any
/// `level_2`, and in this case there should be a single pair of braces.
///
/// The combination of `level_1` and its `value` should be globally unique.
/// `level_2` and `level_3` should be unique within their brace group.
/// "Unique" means that a later entry will replace an earlier.
///
/// # Currently Recognized Arguments
///
/// ## Level 1 `app_config`
///
/// Various attributes configuring the generated application code. No level 1
/// value or level 2 identifiers. Generally recognized level 3 identifiers are
///
/// ### `controller_prefix`
///
/// The value should be a Rust path that is the controllers module prefix, see
/// [`route`](#controller-path-and-handling-method) below.
///
/// Optional, default `crate::controllers`.
///
/// ### `create_session_table`s
///
/// A string literal that is the SQL to create a table to store HTTP session
/// data. The [HTTP server adapter uses this
/// ](../session/struct.DbSession#method.new) to create the table if it does
/// not exist.
///
/// ### `file_root`
///
/// The value should be a string literal, the file system path that is the
/// root of a file system relative path given in a [`route_static`
/// ](#level-1-route_static) entry or an argument to
/// [`HttpServerIf::resp_file()`](struct.HttpServerIf.html#method.resp_file).
///
/// If no leading slash, the working directory of the HTTP server is
/// prepended.
///
/// If not empty and no ending slash, a slash is appended.
///
/// Optional, default `""` meaning the working directory of the HTTP server.
///
/// ### `role_enum`
///
/// The value defines [role-based access control](#role-based-access-control)
/// (RBAC) as follows:
/// - <b>`false`:</b> RBAC is not used.
/// - <b>`true`:</b> RBAC is used, and the role `enum` is
///   `crate::models::UserRole`.
/// - <b>a Rust path:</b> RBAC is used, and the value is the path to the role
///   `enum`.
///
/// Optional, default `true` if `role_variants` are defined, otherwise
/// `false`.
///
/// ### `role_variants`
///
/// The value should be an array of role identifiers, needed by the
/// [authorization](#level-1-authorize) mechanism below.
///
/// Ignored if `role_enum` is `false`. Otherwise optional, default an empty
/// array.
///
/// The predefined role `Superuser` is added if omitted.
///
/// ### `strip_mtime`
///
/// The value should be `true` or `false`. Works together with
/// [`view::make_href()`](../../view/fn.make_href.html). If `true` a dash
/// followed by 10 digits at the end of the file name before the file
/// extension will be stripped before finding a file to serve.
///
/// Optional, default `false`.
///
/// ### `unauthorized_route`
///
/// The value should be a string, the route to redirect to if authentications
/// fails. Note that this is relative to the attribute `url_root`, see below.
///
/// Ignored if `role_enum` is `false`. Otherwise optional, default "/".
///
/// ### `url_root`
///
/// The value should be a string literal, the URL path that is prepended to
/// any URL given in [`authorize(...)`](#level-1-authorize), [`route(...)`
/// ](#level-1-route-and-not_found), [`route_static(...)`
/// ](#level-1-route_static), `unauthorized_route` (see above), or
/// [`view::make_href()` ](../../view/fn.make_href.html).
///
/// Also prepended to an URL argument to [`HttpServerIf::resp_redirect()`
/// ](struct.HttpSeverIf.html#method.resp_redirect) that starts with '/'.
///
/// A leading slash is inserted if missing, a trailing one is removed if
/// present (`""` is left alone, `"/"` is converted to `""`).
///
/// Optional, default `""`.
///
/// ### Server adapter specific attributes
///
/// A server adapter may use its own `app_config` attributes as needed. All
/// attributes defined (and some default values) are accesible by
/// [`HttpServerIf::app_config()`
/// ](struct.HttpServerIf.html#method.app_config)
///
/// ## Level 1 `authorize`
///
/// ### Role Based Access Control
///
/// RBAC may be implemented by giving the `app_config` attribute `role_enum` a
/// value that is not `false`.  The application must implement the trait
/// [`UserRole`](../../authorization/trait.UserRole.html) for the role `enum`.
///
/// ### Route Pattern Authorization
///
/// The level 1 value (between parentheses) is an authorization pattern.  It
/// must match the entire route (stripping the `app_config` attribute
/// [`url_root`](#level-1-app_config) if defined). A slash at the beginning is
/// ignored. It may end with "/*", which matches "" and any string starting
/// with "/".
///
/// If there is no level 2 identifier: The level 3 identifier should be an
/// HTTP method (case insensitive). The value is the `role_variant` that is
/// authorized, or an array of them.
///
/// If there are level 2 identifiers, they should be case insensitive HTTP
/// methods. For each method, the level 3 identifier is either `allow` or
/// `filter`, and the value is again one or more `role_variant`s.
///
/// See below about the use of [`filter`](#filtering-access-control).
///
/// When choosing authorized roles, the longest (up to "/*") matching pattern
/// is used.  If two patterns have the same length and one of them ends in a
/// wildcard and the other not, the latter is chosen.  If none or both of them
/// ends in a wildcard, the first is chosen.
///
/// Example:
/// ```text
/// authorize("/my-route/*") { get { allow: SomeRole } },
/// authorize("/my-route/specific") { get { allow: OtherRole } },
/// authorize("/my-route/general/*") { get: ThirdRole },
/// ```
/// will authorize SomeRole to `/my-route`, `/my-route/whatever`, and
/// `/my-route/specific/whatever` but not to `/my-route/specific`,
/// `/my-route/general`, or `/my-route/general/whatever`.
///
/// OtherRole is authorized only to `/my-route/specific`, while ThirdRole is
/// authorized to `/my-route/general` and `/my-route/general/whatever`.
///
/// The route pattern may include parameters in angle brackets, e.g.
/// `"path/<id>/with/<par>/two/parameters"`, which match any value in that
/// position in the actual path.
///
/// ### Predefined and Pseudo Roles
///
/// The predefined role `Superuser` is always authorized to everything,
/// ignoring route pattern authorization except if `filter`ed, see [below
/// ](#filtering-access-control).
///
/// A user that has the (optional) role `Disabled` is denied access to all
/// routes that do not explicitly allow `Disabled`.
///
/// The pseudo role `Authenticated` is equivalent to an array containing all
/// defined roles, including `Disabled`.
///
/// The pseudo role `Enabled` is equivalent to an array containing all defined
/// roles except `Disabled`.  If `Disabled` is not defined, this is equivalent
/// to `Authenticated`.
///
/// The pseudo role `Public` authorizes access to all clients, ignoring
/// authentication.
///
/// Apart from the predefined `Superuser` there can be any number of roles
/// with arbitrary names except the pseudo role names above. The application
/// must implement the role `enum` as defined by the [`app_config`
/// ](#level-1-app_config) attributes `role_enum` and `role_variants`.
///
/// ### Filtering Access Control
///
/// Using `filter` instead of `allow` when authorizing a role or an array of
/// them means that access is granted only if the handler controller's method
/// [`filter_access()`
/// ](../controller/trait.Controller.html#method.filter_access) returns true.
/// Use `filter` and override `filter_access()` e.g. to allow the logged in
/// user access to their own profile but noone elses, like so:
///
/// ```text
/// // in the config macro the route definition ...
/// route(Users) { create, delete, edit_form, index, patch, show },
/// // ... will create the following paths:
/// //     create     POST  /users
/// //     delete     POST  /users/<id>/delete
/// //     edit_form  GET   /users/<id>/edit
/// //     index      GET   /users
/// //     patch      POST  /users/<id>
/// //     show       GET   /users/<id>
/// // and the authorization ...
///     authorize("/users/<id>/*") {
///         get { filter: Authenticated },
///         post { filter: Authenticated },
///     },
///     authorize("/users/<id>/delete") {
///         post { allow: [] },
///     },
/// // ... together with the following Users controller code ...
///     impl Controller for Users {
///         fn filter_access(db: DatabaseIf, srv: HttpServerIf) -> bool {
///             use crate::models::UserSession; // supposing a UserSession ...
///             srv.req_route_par_val::<u32>("id")
///                 .map(|id| {             // ... with an auth_id() method
///                     id == UserSession::auth_id(db, srv)
///                 })
///                 .unwrap_or(false)
///         }
///         // ... handlers etc
///     }
/// // ... will authorize a logged in user with id 42 to only the following
/// // routes:
/// //     GET   /users/42
/// //     GET   /users/42/edit
/// //     POST  /users/42/patch
/// ```
/// ### Token Authentication
///
/// TODO
///
/// ## Level 1 `plug_in`
///
/// Plug in an object implementing a `vicocomo` trait. Recognized level 1
/// values are identifiers:
/// - `DbConn`: The plug in implements [`DbConn`
///   ](../database/trait.DbConn.html). Optional, default [`NullConn`
///   ](../database/struct.NullConn.html).
/// - `Session`: The plug in implements [`Session`](trait.Session.html).
///   Optional, default [`NullSession`](struct.NullSession.html).
/// - `TemplEng`: The plug in mplements [`TemplEng`](trait.TemplEng.html).
///   Optional, default [`NullTemplEng`](struct.NullTemplEng.html).
///
/// All require no level 2 and one level 3 arg `def`:
/// ```text
/// plug_in(SomeTrait) {
///     def: (
///         <a type implementing vicocomo::SomeTrait>,
///         <an expression evaluating to an instance of the type>,
///     ),
/// },
/// ```
///
/// ## Level 1 `route` and `not_found`
///
/// Route configuration. At least one route must obviously be defined.
/// Example follows.  See [Controller path and handling method
/// ](#controller-path-and-handling-method) below for the meaning of
/// "*Control*" in `route(`*Control*`)`.
/// ```text
///                        // HTTP | Path (params in <>)  | ctrl | method
///                        // =====+======================+======+============
/// route(Rsrc) {          //   CRUD requests, only those given are generated
/// // Create request         -----+----------------------+------+------------
///   new_form,            // get  | "/rsrc/new"          | Rsrc | new_form
///   copy_form,           // get  | "/rsrc/<id>/copy"    | Rsrc | copy_form
///   create,              // post | "/rsrc"              | Rsrc | create
///   ensure,              // post | "/rsrc/ensure"       | Rsrc | ensure
/// // Read request           -----+----------------------+------+------------
///   index,               // get  | "/rsrc"              | Rsrc | index
///   show,                // get  | "/rsrc/<id>"         | Rsrc | show
/// // Update request         -----+----------------------+------+------------
///   edit_form,           // get  | "/rsrc/<id>/edit"    | Rsrc | edit_form
///   patch,               // post | "/rsrc/<id>"         | Rsrc | patch
///   replace,             // post | "/rsrc/<id>/replace" | Rsrc | replace
/// // Delete request         -----+----------------------+------+------------
///   delete,              // post | "/rsrc/<id>/delete"  | Rsrc | delete
/// },                     // =====+======================+======+============
/// route(Cust) {          //   Methods may be customized |      |
///   custom {             // -----+----------------------+------+------------
///     http_method: post, //   Default GET
///     path: "path",      // post | "/path"              | Cust | custom
/// }},                    // =====+======================+======+============
/// route(Sing) {          //   Example: configure a singleton resource
///   new_form,            // get  | "/sing/new"          | Sing | new_form
///   create,              // post | "/sing"              | Sing | create
///   ensure,              // post | "/sing/ensure"       | Sing | ensure
///   show                 //   Full path must be given if leading slash
///   { path: "/sing" },   // get  | "/sing"              | Sing | show
///   edit_form            //   Resource snake prepended if no leading slash
///   { path: "edit" },    // get  | "/sing/edit"         | Sing | edit_form
///   patch { path: "" },  // post | "/sing"              | Sing | patch
///   replace              //      |                      |      |
///   { path: "replace" }, // post | "/sing/replace"      | Sing | replace
///   delete               //      |                      |      |
///   { path: "delete" },  // post | "/sing/delete"       | Sing | delete
/// },                     // =====+======================+======+============
/// route(Othr) {          //   Customized path parameters are given as
///   parm_req { path:     // <param> (parameter name ignored)
///     "some/<param>",    // get  | "/some/<p0>"         | Othr | parm_req
///   },                   // -----+----------------------+------+------------
///   post_req {           //   Except for the standardized CRUD requests
///     http_method: post, // above, GET is the default HTTP method
///     path: "postpth",   // post | "/postpth"           | Othr | post_req
/// }},                    // =====+======================+======+============
/// // Not Found handler   //      |                      |      |
/// not_found(Hand) {func} //   All not handled elsewhere,| Hand | func
///                        // no default provided by parse()
/// ```
///
/// ### Prepending an URL root
///
/// Note that the path given in a `route` entry is relative to the
/// `app_config` attribute [`url_root`](#level-1-app_config).
///
/// ### Controller Path and Handling Method
///
/// The controller is given as `some::path::to::Controller`. If the path is a
/// single identifier, as in the examples, the `controller_prefix` [attribute
/// ](#level-1-app_config) value (default `crate::controllers::`) is
/// prepended.
///
/// The handling methods are called as
/// `some::path::to::Controller::handler(...)`. So the controller may be a
/// module, struct, or enum as long as the handling method does not have a
/// receiver.
///
/// Handling method signature:
/// ```text
/// (
///     vicocomo::DatabaseIf,
///     vicocomo::HttpServerIf,
///     vicocomo::TemplEngIf,
/// ) -> ()
/// ```
/// Note that there is no return value. Errors should be forwarded using
/// methods in [`HttpServerIf`](struct.HttpServerIf.html).
///
/// ## Level 1 `route_static`
///
/// Configure the server to serve static files from a file system directory.
///
/// The value is a string literal, the URL path. Note that this is relative to
/// the `app_config` attribute [`url_root`](#level-1-app_config). Leading and
/// trailing slashes are ignored.
///
/// No level 2.
///
/// Currently only one level 3 `fs_path:` which should have a value that is a
/// string literal, the file system path. If it starts with a slash it is an
/// absolute file path, if not it is relative to the one given by the
/// `app_config` attribute [`file_root`](#level-1-app_config).
///
/// `fs_path` is optional, the default is the URL path value.
///
/// All directories must be explicitly given, e.g to access files from `"dir"`
/// and `"dir/sub"` you must do `route_static("dir"), route_static("dir/sub").
///
/// <small>Note: To define an URL for serving a specific file (not all files
/// in a directory), use [level 1 `route`](#level-1-route-and-not_found) and
/// write a handler that uses [`HttpServerIf::resp_file()`
/// ](struct.HttpServerIf.html#method.resp_file).</small>
///
/// If the same URL is defined by `route` and `route_static`, the HTTP server
/// adapter chooses the `route`.

// --- for HTTP server adapter developers only -------------------------------

// - - Config and friends  - - - - - - - - - - - - - - - - - - - - - - - - - -

#[derive(Clone, Debug)]
pub struct Config {
    /// ### For HTTP server adapter developers only
    ///
    /// Parsed `app_config` attributes.  This will always contain the
    /// predefined entries as documented for [`HttpServerIf::app_config()`
    /// ](struct.HttpServerIf.html#method.app_config).
    ///
    pub app_config: HashMap<String, ConfigAttrVal>,

    /// ### For HTTP server adapter developers only
    ///
    /// Optional custom handler for failed routes.
    ///
    pub not_found: Option<(Path, Ident)>,

    /// ### For HTTP server adapter developers only
    ///
    /// The `Type` implements a trait `vicocomo::`*the `String`*.
    ///
    /// The `Expr` evaluates to the `Type`.
    ///
    pub plug_ins: HashMap<String, (Type, Expr)>,

    /// ### For HTTP server adapter developers only
    ///
    /// The routing targets, mapping a controller to its route handlers.
    ///
    pub routes: HashMap<Path, Vec<Handler>>,

    /// ### For HTTP server adapter developers only
    ///
    /// The first `String` in each pair is the part of the URL path preceding
    /// the file name with leading but no trailing slash. The `app_config`
    /// attribute [`url_root`](#level-1-app_config) is already added by the
    /// parser.
    ///
    /// <small>Note that the complete URL, including the file name, may
    /// possibly coincide with an URL in a `Handler` in `routes`. In such
    /// cases the HTTP server is expected to call the handler and ignore the
    /// file. </small>
    ///
    /// The second `String` is the directory that the file is served from. If
    /// it begins with a slash it is an absolute file path. If not, it is
    /// relative to the HTTP server's working directory. No trailing slash.
    ///
    /// The `app_config` attribute [`file_root`](#level-1-app_config) is
    /// already prepended by [`parse()`](#method.parse).
    ///
    pub static_routes: Vec<(String, String)>,
}

// ---------------------------------------------------------------------------

/// ### For HTTP server adapter developers only
///
/// The possible values of a level 3 configuration attribute.
///
#[derive(Clone, Debug)]
pub enum ConfigAttrVal {
    /// The elements of the array are guaranteed to be the same variant.
    Arr(Vec<ConfigAttrVal>),
    Bool(LitBool),
    Char(LitChar),
    Float(LitFloat),
    /// The contained `Ident` is guaranteed not to be `false` or `true`.
    Ident(Ident),
    Int(LitInt),
    /// The contained `Path` is guaranteed not to be a single `Ident`.
    Path(Path),
    Str(LitStr),
    /// The expression should evaluate to an instance of the type.
    TypeExpr(Type, Expr),
}

macro_rules! literal_extractor {
    ($self: ident, $variant: ident $( , )? ) => {
        if let ConfigAttrVal::$variant(v) = $self {
            Ok(v.clone())
        } else {
            Err($self.error("Literal error"))
        }
    };
}

impl ConfigAttrVal {
    fn error(&self, msg: &str) -> syn::Error {
        syn_error(&format!("{}: {}", msg, &self))
    }

    /// Return the contained array or an error. The elements of the array are
    /// guaranteed to be the same variant.
    ///
    pub fn get_array(&self) -> syn::Result<Vec<ConfigAttrVal>> {
        match self {
            ConfigAttrVal::Arr(a) => Ok(a.clone()),
            _ => Err(self.error("Not an array")),
        }
    }

    /// - A clone of the contained Arr of Ident as String, or
    /// - the contained Ident as a vector with one String, or
    /// - an error.
    ///
    pub fn get_id_strings(&self) -> syn::Result<Vec<String>> {
        match self {
            ConfigAttrVal::Arr(a) => {
                let mut result = Vec::new();
                for elem in a {
                    if let Self::Ident(id) = elem {
                        result.push(id.to_string());
                    } else {
                        return Err(self.error("Not an Ident array"));
                    }
                }
                Ok(result)
            }
            ConfigAttrVal::Ident(id) => Ok(vec![id.to_string()]),
            _ => Err(self.error("Not an Ident (array)")),
        }
    }

    /// Return the contained boolean or an error.
    ///
    pub fn get_bool(&self) -> syn::Result<bool> {
        literal_extractor!(self, Bool).map(|b| b.value())
    }

    /// Return the contained character or an error.
    ///
    pub fn get_char(&self) -> syn::Result<char> {
        literal_extractor!(self, Char).map(|c| c.value())
    }

    /// Return the contained float or an error.
    ///
    pub fn get_f64(&self) -> syn::Result<f64> {
        literal_extractor!(self, Float).and_then(|f| f.base10_parse().into())
    }

    /// Return the contained integer or an error.
    ///
    pub fn get_i64(&self) -> syn::Result<i64> {
        literal_extractor!(self, Int).and_then(|i| i.base10_parse().into())
    }

    /// Return the contained identifier or an error.
    ///
    pub fn get_ident(&self) -> syn::Result<Ident> {
        match self {
            ConfigAttrVal::Ident(i) => Ok(i.clone()),
            _ => Err(self.error("Not an Ident")),
        }
    }

    /// Return the contained `LitStr` or an error.
    ///
    pub fn get_litstr(&self) -> syn::Result<LitStr> {
        literal_extractor!(self, Str)
    }

    /// Return the contained Rust path, or identifier as a path, or an error.
    ///
    pub fn get_path(&self) -> syn::Result<Path> {
        match self {
            ConfigAttrVal::Ident(i) => Ok(parse_quote!(#i)),
            ConfigAttrVal::Path(p) => Ok(p.clone()),
            _ => Err(self.error("Not a Path")),
        }
    }

    /// Return the contained string or an error.
    ///
    pub fn get_string(&self) -> syn::Result<String> {
        literal_extractor!(self, Str).map(|s| s.value())
    }

    // get_string() and then fix_slashes()
    fn get_fix_slashes(&self, lead: i32, trail: i32) -> syn::Result<String> {
        Ok(crate::fix_slashes(&self.get_string()?, lead, trail))
    }

    /// Return the contained (Type, Expr) pair or an error.
    ///
    pub fn get_type_expr(&self) -> syn::Result<(Type, Expr)> {
        match self {
            ConfigAttrVal::TypeExpr(t, e) => Ok((t.clone(), e.clone())),
            _ => Err(syn_error(&format!("{} is not a (Type, Expr)", &self))),
        }
    }

    /// ### For HTTP server adapter developers only
    ///
    /// Use in the HTTP server adapter's `config` macro to initialize the
    /// container behind the implementation of [`HttpServer::app_config()`
    /// ](trait.HttpServer.html#method.app_config).
    ///
    /// Convert to an `Expr` that evaluates to an [`AppConfigVal`
    /// ](enum.AppConfigVal.html).
    ///
    /// Guaranteed to return Some(_) for all variants except for `TypeExpr`
    /// returning `None`.
    ///
    pub fn to_app_config_val_expr(&self) -> Option<Expr> {
        use proc_macro2::Span;
        use syn::punctuated::Punctuated;
        match self {
            Self::Arr(vals) => {
                let mut elems: Punctuated<Expr, syn::token::Comma> =
                    Punctuated::new();
                for v in vals {
                    if let Some(elem) = v.to_app_config_val_expr() {
                        elems.push(elem);
                    } else {
                        return None;
                    }
                }
                Some(parse_quote!(vicocomo::AppConfigVal::Arr(vec![#elems])))
            }
            Self::Bool(val) => {
                Some(parse_quote!(vicocomo::AppConfigVal::Bool(#val)))
            }
            Self::Char(val) => {
                Some(parse_quote!(vicocomo::AppConfigVal::Char(#val)))
            }
            Self::Float(val) => {
                Some(parse_quote!(vicocomo::AppConfigVal::Float(#val)))
            }
            Self::Ident(val) => {
                let id_str = LitStr::new(&val.to_string(), Span::call_site());
                Some(parse_quote!(vicocomo::AppConfigVal::Ident(
                    #id_str.to_string()
                )))
            }
            Self::Int(val) => {
                Some(parse_quote!(vicocomo::AppConfigVal::Int(#val)))
            }
            Self::Path(val) => {
                let p_str = LitStr::new(
                    &vicocomo_derive_utils::tokens_to_string(&val),
                    Span::call_site(),
                );
                Some(parse_quote!(vicocomo::AppConfigVal::Path(
                    #p_str.to_string()
                )))
            }
            Self::Str(val) => Some(
                parse_quote!(vicocomo::AppConfigVal::Str(#val.to_string())),
            ),
            Self::TypeExpr(..) => None,
        }
    }
}

impl Display for ConfigAttrVal {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        use itertools::Itertools;
        match self {
            Self::Arr(v) => {
                write!(f, "[{}]", v.iter().map(|i| i.to_string()).join(", "))
            }
            Self::Bool(b) => write!(f, "{}", b.value().to_string()),
            Self::Char(c) => write!(f, "{}", c.value().to_string()),
            Self::Float(e) => {
                write!(f, "{}", e.base10_parse::<f64>().unwrap().to_string())
            }
            Self::Ident(i) => write!(f, "{}", i.to_string()),
            Self::Int(i) => {
                write!(f, "{}", i.base10_parse::<i64>().unwrap().to_string())
            }
            Self::Path(p) => write!(f, "{}", tokens_to_string(p)),
            Self::Str(s) => write!(f, "{}", s.value()),
            Self::TypeExpr(t, e) => write!(
                f,
                "({}, {})",
                tokens_to_string(t),
                tokens_to_string(e),
            ),
        }
    }
}

macro_rules! cav_from_value {
    ($typ:ty, $variant:ident, $lit:ident) => {
        impl From<$typ> for ConfigAttrVal {
            fn from(val: $typ) -> Self {
                Self::$variant(syn::$lit::new(
                    val,
                    proc_macro2::Span::call_site(),
                ))
            }
        }
    };
}

impl<T: Into<ConfigAttrVal>> From<Vec<T>> for ConfigAttrVal {
    fn from(arr: Vec<T>) -> Self {
        Self::Arr(arr.into_iter().map(|val| val.into()).collect())
    }
}

cav_from_value! { bool, Bool, LitBool }
cav_from_value! { char, Char, LitChar }

impl From<&str> for ConfigAttrVal {
    fn from(s: &str) -> Self {
        Self::Str(LitStr::new(s, proc_macro2::Span::call_site()))
    }
}

/// # For HTTP server adapter developers only
///
/// Information needed for implementing an HTTP server configuration macro
/// using [`Config`](struct.Config.html).
#[derive(Clone, Debug)]
pub struct Handler {
    /// If `Some`, defines access control for `route`, see [`Authorized`
    /// ](struct.Authorized.html). If `None`, there is no access control.
    pub authorized: Option<Authorized>,

    /// controller method name.
    pub contr_method: Ident,

    /// only tested for Get and Post.
    ///
    pub http_method: HttpMethod,

    /// Route, possibly with path parameters in angle brackets. The
    /// `app_config` attribute [`url_root`](#level-1-app_config) is prepended
    /// if defined. Use [`Config::strip_url_root()`
    /// ](struct.Config.html#method.strip_url_root) to get the relative URL.
    ///
    pub route: String,

    /// Route parameter names.
    ///
    pub route_par_names: Vec<LitStr>,
}

/// # For HTTP server adapter developers only
///
/// Used by a web server adapter to implement [role based access control
/// ](struct.Config.html#role-based-access-control), utilizing the role
/// `enum`'s [`is_authenticated()`
/// ](struct.Config.html#role-based-access-control) method.
///
/// A user that has the (optional) role `Disabled` shall be allowed access
/// only if `Disabled` is present in `allow`.
///
/// A user that does not have the role `Disabled` shall be allowed access if
/// any of its roles is present in `allow`.
///
/// Whether `Disabled` or not, if `filter` is `true` access shall be allowed
/// only after [filtering](#filtering-access-control).
///
/// The role `Superuser` is guaranteed always to be present in `allow`.
///
#[derive(Clone, Debug)]
pub struct Authorized {
    /// Each `Expr` evaluates to a [role `enum`
    /// ](struct.Config.html#role-based-access-control).
    pub allow: Vec<Expr>,

    /// Allow access to the `allow` roles only after [filtering
    /// ](struct.Config.html#filtering-access-control).
    pub filter: bool,
}

/// # For HTTP server adapter developers only
///
/// A simple enum with the official methods.
///
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd, Hash)]
pub enum HttpMethod {
    Connect,
    Delete,
    Get,
    Head,
    Options,
    Patch,
    Post,
    Put,
    Trace,
}

impl Copy for HttpMethod {}

impl Display for HttpMethod {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Connect => "connect",
                Self::Delete => "delete",
                Self::Get => "get",
                Self::Head => "head",
                Self::Options => "options",
                Self::Patch => "patch",
                Self::Post => "post",
                Self::Put => "put",
                Self::Trace => "trace",
            }
        )
    }
}

impl TryFrom<&str> for HttpMethod {
    type Error = Error;
    fn try_from(s: &str) -> Result<Self, Error> {
        match s.to_lowercase().as_str() {
            "connect" => Ok(HttpMethod::Connect),
            "delete" => Ok(HttpMethod::Delete),
            "get" => Ok(HttpMethod::Get),
            "head" => Ok(HttpMethod::Head),
            "options" => Ok(HttpMethod::Options),
            "patch" => Ok(HttpMethod::Patch),
            "post" => Ok(HttpMethod::Post),
            "put" => Ok(HttpMethod::Put),
            "trace" => Ok(HttpMethod::Trace),
            &_ => Err(Error::other(&format!("{} is not an HTTP method", s))),
        }
    }
}

// - - HttpServer and friends  - - - - - - - - - - - - - - - - - - - - - - - -

/// # For HTTP server adapter developers only
///
/// Everything Vicocomo needs from an HTTP server.
///
pub trait HttpServer {
    /// See [`HttpServerIf::app_config()`
    /// ](struct.HttpServerIf.html#method.app_config).
    ///
    fn app_config(&self, id: &str) -> Option<AppConfigVal>;

    /// See [`HttpServerIf::param_val()`
    /// ](struct.HttpServerIf.html#method.param_val), but this one returns a
    /// `String`.
    ///
    fn param_val(&self, name: &str) -> Option<String>;

    /// All parameter values in the URL (get) or body (post) as a vector of
    /// URL-decoded key-value pairs.
    ///
    fn param_vals(&self) -> Vec<(String, String)>;

    /// See [`HttpServerIf::req_path()`
    /// ](struct.HttpServerIf.html#method.req_path), but this one <b>does not
    /// strip</b> the `url_root` [attribute](#level-1-app_config).
    ///
    fn req_path(&self) -> String;

    /// See [`HttpServerIf::req_route_par_val()`
    /// ](struct.HttpServerIf.html#method.req_route_par_val), but this one
    /// returns a `String`.
    ///
    fn req_route_par_val(&self, par: &str) -> Option<String>;

    /// See [`HttpServerIf::req_route_par_vals()`
    /// ](struct.HttpServerIf.html#method.req_route_par_vals).
    ///
    fn req_route_par_vals(&self) -> Vec<(String, String)>;

    /// See [`HttpServerIf::req_body()`
    /// ](struct.HttpServerIf.html#method.req_body).
    ///
    fn req_body(&self) -> String;

    /// See [`HttpServerIf::req_url()`
    /// ](struct.HttpServerIf.html#method.req_url).
    ///
    fn req_url(&self) -> String;

    /// See [`HttpServerIf::resp_body()`
    /// ](struct.HttpServerIf.html#method.resp_body).
    ///
    fn resp_body(&self, txt: &str);

    /// See [`HttpServerIf::resp_error()`
    /// ](struct.HttpServerIf.html#method.resp_error).
    ///
    fn resp_error(&self, err: Option<&Error>);

    /// Serve a static file, ignoring the body.
    ///
    /// `file_path` is the absolute path of the file if it starts with '`/`',
    /// or relative to the HTTP server's working directory if it does not.
    ///
    fn resp_file(&self, file_path: &str);

    /// See [`HttpServerIf::resp_ok()`](struct.HttpServerIf.html#method.resp_ok).
    ///
    fn resp_ok(&self);

    /// See [`HttpServerIf::resp_redirect()`
    /// ](struct.HttpServerIf.html#method.resp_redirect).
    ///
    fn resp_redirect(&self, url: &str);

    /// See [`HttpServerIf::session_clear()`
    /// ](struct.HttpServerIf.html#method.session_clear).
    ///
    fn session_clear(&self);

    /// See [`HttpServerIf::session_get()`
    /// ](struct.HttpServerIf.html#method.session_get), but the JSON is not
    /// decoded.
    ///
    fn session_get(&self, key: &str) -> Option<String>;

    /// See [`HttpServerIf::session_remove()`
    /// ](struct.HttpServerIf.html#method.session_remove).
    ///
    fn session_remove(&self, key: &str);

    /// See [`HttpServerIf::session_set()`
    /// ](struct.HttpServerIf.html#method.session_set), but the value is
    /// already JSON-serialized on entry.
    ///
    fn session_set(&self, key: &str, value: &str) -> Result<(), Error>;

    /// See [`HttpServerIf::url_path_to_dir()`
    /// ](struct.HttpServerIf.html#method.url_path_to_dir), but
    /// - `url_path` includes [`url_root`](struct.Config.html#url_root) and is
    ///   guaranteed not to end with a slash, and
    /// - the returned string includes [`file_root`
    ///   ](struct.Config.html#file_root).
    ///
    fn url_path_to_dir(&self, url_path: &str) -> Option<String>;
}

// - - TemplEng and friends  - - - - - - - - - - - - - - - - - - - - - - - - -

/// # For HTTP server adapter developers only
///
/// Methods to render via a template engine.
///
pub trait TemplEng {
    /// Override to render.
    ///
    /// `data` is data for the template as `serde_json::Value`.
    ///
    #[allow(unused_variables)]
    fn render(&self, tmpl: &str, json: &JsonValue) -> Result<String, Error>;
}

/// # For HTTP server adapter developers only
///
/// An implementation of [`TemplEng`](trait.TemplEng.html) that does nothing
/// and returns [`Error`](../error/enum.Error.html).
///
#[derive(Clone, Copy, Debug)]
pub struct NullTemplEng;

impl TemplEng for NullTemplEng {
    fn render(
        &self,
        _tmpl: &str,
        _json: &JsonValue,
    ) -> Result<String, Error> {
        Err(Error::render("no template engine"))
    }
}

// --- private --------------------------------------------------------------

use regex::{CaptureMatches, Regex};
use std::iter::Peekable;

lazy_static::lazy_static! {
    static ref ROUTE_PARAMS: Regex = Regex::new(r"(<[^>]*>)").unwrap();
}

// - - HttpServerIf helpers  - - - - - - - - - - - - - - - - - - - - - - - - -

#[derive(Clone, Debug)]
enum FormData {
    Arr(Vec<FormData>),
    Map(HashMap<String, FormData>),
    Leaf(String),
}

impl FormData {
    // Expect self to be a Map and value to be a Leaf.
    // Depending on more_keys.next():
    // - None => insert value in self at key
    // - "" => recurse to push() to the Arr in self at key, or create the Arr
    // - => recurse to insert() in the Map in self at key
    fn insert(
        &mut self,
        key: String,
        mut more_keys: Peekable<CaptureMatches>,
        value: Self,
    ) -> Result<(), Error> {
        if let FormData::Map(ref mut map) = self {
            match more_keys.next() {
                None => {
                    map.insert(key, value);
                }
                Some(next_match) => {
                    let next_key = next_match.get(1).unwrap().as_str();
                    if next_key.len() == 0 {
                        if map.get(&key).is_none() {
                            map.insert(
                                key.to_string(),
                                Self::Arr(Vec::new()),
                            );
                        }
                        map.get_mut(&key).unwrap().push(more_keys, value)?
                    } else {
                        if map.get(&key).is_none() {
                            map.insert(
                                key.to_string(),
                                Self::Map(HashMap::new()),
                            );
                        }
                        map.get_mut(&key).unwrap().insert(
                            next_key.to_string(),
                            more_keys,
                            value,
                        )?
                    }
                }
            }
            Ok(())
        } else {
            Err(Error::invalid_input("self is not a Map variant"))
        }
    }

    // Expect self to be an Arr and value to be a Leaf.
    // Depending on more_keys.next():
    // - None => push value on self
    // - "" => recurse to push() to the Arr last in self
    // - => recurse to insert() in the Map last in self
    fn push(
        &mut self,
        mut more_keys: Peekable<CaptureMatches>,
        value: Self,
    ) -> Result<(), Error> {
        if let FormData::Arr(ref mut arr) = self {
            match more_keys.next() {
                None => arr.push(value),
                Some(next_match) => {
                    let next_key = next_match.get(1).unwrap().as_str();
                    if next_key.len() == 0 {
                        if arr.is_empty() {
                            arr.push(Self::Arr(Vec::new()));
                        }
                        arr.last_mut().unwrap().push(more_keys, value)?
                    } else {
                        if arr.is_empty() {
                            arr.push(Self::Map(HashMap::new()));
                        }
                        arr.last_mut().unwrap().insert(
                            next_key.to_string(),
                            more_keys,
                            value,
                        )?
                    }
                }
            }
            Ok(())
        } else {
            Err(Error::invalid_input("self is not an Arr variant"))
        }
    }

    // vals is [(<URL or body parameter name>, <URL-decoded string value>)].
    // The parameter name should be e.g. "foo[bar][]" indicating that the
    // value is an element in an array that is a value with key "bar" in a
    // map that is the value with key "foo" in the returned FormData::Map.
    fn parse(vals: Vec<(String, String)>) -> Result<Self, Error> {
        lazy_static::lazy_static! {
            static ref BRACKETS: Regex = Regex::new(r"\[([^]]*)\]").unwrap();
        }
        let mut result = FormData::Map(HashMap::new());
        for (raw_key, raw_val) in vals {
            let val = Self::Leaf(raw_val);
            let mut nested = BRACKETS.captures_iter(&raw_key).peekable();
            let key = if let Some(mtch) = nested.peek() {
                &raw_key[0..mtch.get(0).unwrap().start()]
            } else {
                &raw_key
            };
            result.insert(key.to_string(), nested, val)?;
        }
        Ok(result)
    }
}

impl Serialize for FormData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::{SerializeMap, SerializeSeq};
        match self {
            Self::Arr(a) => {
                let mut seq = serializer.serialize_seq(Some(a.len()))?;
                for e in a {
                    seq.serialize_element(e)?;
                }
                seq.end()
            }
            Self::Map(m) => {
                let mut map = serializer.serialize_map(Some(m.len()))?;
                for (k, v) in m {
                    map.serialize_entry(k, v)?;
                }
                map.end()
            }
            Self::Leaf(l) => serializer.serialize_str(l),
        }
    }
}

/// Extract the parameter names from `route`.
///
fn get_route_pars(route: &str) -> Vec<LitStr> {
    use proc_macro2::Span;
    ROUTE_PARAMS
        .find_iter(route)
        .map(|p| {
            let s = p.as_str();
            LitStr::new(&s[1..s.len() - 1], Span::call_site())
        })
        .collect()
}

// - - Config helpers  - - - - - - - - - - - - - - - - - - - - - - - - - - - -

macro_rules! prepend_root {
    // prepend file_root if not starts with '/'
    (file $root:expr, $path:expr) => {
        if ($path).starts_with('/') {
            ($path).to_string()
        } else {
            ($root).to_string() + ($path)
        }
    };
    // prepend url_root if starts with '/'
    (url $root:expr, $path:expr) => {
        if ($path).starts_with('/') {
            ($root).to_string() + ($path)
        } else {
            ($path).to_string()
        }
    };
}

// ensure that there is a root string and fix_slashes()
fn fix_root(
    app_config: &mut HashMap<String, ConfigAttrVal>,
    root: &str,
    lead: i32,
    trail: i32,
) -> String {
    let inserted = app_config.get(root).map(|val| val.get_string().unwrap());
    let result = inserted
        .as_ref()
        .map(|s| crate::fix_slashes(s, lead, trail))
        .unwrap_or_else(|| String::new());
    if match inserted {
        Some(s) => s != result,
        None => true,
    } {
        app_config.insert(root.to_string(), result.as_str().into());
    }
    result
}

impl Parse for Config {
    /// ### For HTTP server adapter developers only
    ///
    /// In addition to simple parsing, this function also implements rules as
    /// documented [above](struct.Config.html).
    ///
    fn parse(stream: ParseStream) -> syn::Result<Self> {
        let mut app_config = HashMap::new();
        let mut authorizers = Authorizers::new();
        let mut not_found = None;
        let mut plug_ins = HashMap::new();
        let mut parsed_routes = Vec::new();
        let mut static_routes = Vec::new();
        for item in stream
            .parse_terminated::<ConfigItem, token::Comma>(ConfigItem::parse)?
        {
            match item.level_1 {
                ConfigItemId::AppConfig => {
                    item.get_app_conf(&mut app_config)?
                }
                ConfigItemId::Authorize => {
                    item.get_authorizer(&mut authorizers)?
                }
                ConfigItemId::NotFound => {
                    item.get_not_found(&mut not_found)?
                }
                ConfigItemId::PlugIn => item.get_plug_in(&mut plug_ins)?,
                ConfigItemId::Routes => {
                    item.get_routes(&mut parsed_routes)?
                }
                ConfigItemId::StaticRoutes => {
                    item.get_static_routes(&mut static_routes)?
                }
            }
        }

        // - - app_config defaults and business rules  - - - - - - - - - - - -

        let contr_prefix: Path = match app_config.get("controller_prefix") {
            Some(val) => val.get_path()?,
            None => {
                let path: Path = parse_quote!(crate::controllers);
                app_config.insert(
                    "controller_prefix".to_string(),
                    ConfigAttrVal::Path(path.clone()),
                );
                path
            }
        };
        let file_root = fix_root(&mut app_config, "file_root", 0, 1);
        let role_type: Option<Type> = {
            let mut default = true;
            let mut role_type: Option<Type> = None;
            if let Some(val) = app_config.get_mut("role_enum") {
                if let Ok(p) = val.get_path() {
                    default = false;
                    role_type = Some(parse_quote!(#p));
                } else {
                    if let Ok(b) = val.get_bool() {
                        if b {
                            *val = ConfigAttrVal::Path(parse_quote!(
                                crate::models::UserRole
                            ));
                        } else {
                            default = false;
                        }
                    }
                }
            } else if app_config.contains_key("role_variants") {
                app_config.insert(
                    "role_enum".to_string(),
                    ConfigAttrVal::Path(parse_quote!(
                        crate::models::UserRole
                    )),
                );
            } else {
                app_config.insert(
                    "role_enum".to_string(),
                    ConfigAttrVal::Bool(parse_quote!(false)),
                );
                default = false;
            }
            if default {
                role_type = Some(parse_quote!(crate::models::UserRole));
            }
            role_type
        };
        if role_type.is_some() {
            let mut roles = match app_config.get("role_variants") {
                Some(v) => v.get_id_strings()?,
                None => Vec::new(),
            };
            for predefined in &["Superuser"] {
                let predef = predefined.to_string();
                if !roles.contains(&predef) {
                    roles.push(predef);
                }
            }
            authorizers.sanitize(roles.as_slice())?;
            match app_config.get("unauthorized_route") {
                Some(r) => {
                    r.get_string()?;
                }
                None => {
                    app_config.insert(
                        "unauthorized_route".to_string(),
                        ConfigAttrVal::Str(parse_quote!("/")),
                    );
                }
            }
        }
        app_config
            .get("strip_mtime")
            .map(|val| val.get_bool().map(|_| ()))
            .unwrap_or_else(|| {
                Ok({
                    app_config
                        .insert("strip_mtime".to_string(), false.into());
                })
            })?;
        let url_root = fix_root(&mut app_config, "url_root", 1, -1);

        // - - plugin defaults - - - - - - - - - - - - - - - - - - - - - - - -

        if !plug_ins.contains_key("DbConn") {
            plug_ins.insert(
                "DbConn".to_string(),
                (
                    parse_quote!(vicocomo::NullConn),
                    parse_quote!(vicocomo::NullConn),
                ),
            );
        }
        if !plug_ins.contains_key("Session") {
            plug_ins.insert(
                "Session".to_string(),
                (
                    parse_quote!(vicocomo::NullSession),
                    parse_quote!(vicocomo::NullSession),
                ),
            );
        }
        if !plug_ins.contains_key("TemplEng") {
            plug_ins.insert(
                "TemplEng".to_string(),
                (
                    parse_quote!(vicocomo::NullTemplEng),
                    parse_quote!(vicocomo::NullTemplEng),
                ),
            );
        }

        // - - handler defaults and business rules - - - - - - - - - - - - - -

        let mut routes: HashMap<Path, Vec<Handler>> = HashMap::new();
        for (mut contr_path, mut handler) in parsed_routes.drain(..) {
            match contr_path.get_ident() {
                Some(id) => {
                    contr_path.segments = parse_quote!(#contr_prefix::#id);
                }
                None => (),
            }
            // must do authorize before prepending url_root
            if role_type.is_some() {
                handler.authorize(
                    authorizers.get(handler.http_method)?,
                    role_type.as_ref().unwrap(),
                )?;
            }
            handler.route = prepend_root!(url & url_root, &handler.route);
            match routes.get_mut(&contr_path) {
                Some(hands) => hands.push(handler),
                None => {
                    routes.insert(contr_path, vec![handler]);
                }
            }
        }

        // - - static route business rules - - - - - - - - - - - - - - - - - -

        for (url, file) in static_routes.iter_mut() {
            *url = prepend_root!(url url_root.as_str(), url.as_str());
            *file = prepend_root!(file file_root.as_str(), file.as_str());
        }

        Ok(Self {
            app_config,
            not_found,
            plug_ins,
            routes,
            static_routes,
        })
    }
}

impl Handler {
    fn authorize(
        &mut self,
        authorizers: &[Authorizer],
        role_type: &Type,
    ) -> syn::Result<()> {
        for auth in authorizers {
            if auth.pattern.is_match(&self.route) {
                if auth.roles == vec!["Public".to_string()] {
                    return Ok(());
                }
                let mut allow: Vec<Expr> = auth
                    .roles
                    .iter()
                    .map(|s| {
                        let variant = format_ident!("{}", s);
                        parse_quote!(#role_type::#variant)
                    })
                    .collect();
                if !auth.roles.contains(&"Superuser".to_string()) {
                    allow.push(parse_quote!(#role_type::Superuser));
                }
                self.authorized = Some(Authorized {
                    allow,
                    filter: auth.filter,
                });
                return Ok(());
            }
        }
        Err(syn_error(&format!(
            "no authorization for route {}",
            self.route
        )))
    }
}

#[derive(Clone, Debug)]
struct ConfigItem {
    level_1: ConfigItemId,
    value: Option<ConfigAttrVal>,
    level_2: Vec<Level2>,
}

#[derive(Clone, Copy, Debug)]
enum ConfigItemId {
    AppConfig,
    Authorize,
    NotFound,
    PlugIn,
    Routes,
    StaticRoutes,
}

impl ConfigItem {
    // assumes level_1 to be AppConfig
    fn get_app_conf(
        &self,
        app_config: &mut HashMap<String, ConfigAttrVal>,
    ) -> syn::Result<()> {
        self.level_2.first().map(|l2| {
            for attr in &l2.attrs {
                app_config.insert(attr.id.to_string(), attr.val.clone());
            }
        });
        Ok(())
    }

    // assumes level_1 to be Authorize
    fn get_authorizer(
        &self,
        authorizers: &mut Authorizers,
    ) -> syn::Result<()> {
        let mut pat_str = self
            .value
            .as_ref()
            .ok_or_else(|| syn_error("missing authorize pattern"))?
            .get_string()?;
        // ensure slash at beginning
        if pat_str.get(0..1).map(|c| c != "/").unwrap_or(true) {
            pat_str.insert(0, '/');
        }
        let wild = pat_str.len() >= 2
            && pat_str
                .get((pat_str.len() - 2)..)
                .map(|s| s == "/*")
                .unwrap_or(false);
        let pat_tail;
        if wild {
            pat_str.truncate(pat_str.len() - 2);
            pat_tail = r"(/.*)?$";
        } else {
            pat_tail = r"$";
        }
        pat_str += pat_tail;
        pat_str = ROUTE_PARAMS.replace_all(&pat_str, r"([^/]+)").to_string();
        let pattern =
            Regex::new(&pat_str).map_err(|e| syn_error(&e.to_string()))?;
        let priority = 2 * (pat_str.len() - pat_tail.len()) + wild as usize;
        for l2 in self.level_2.as_slice() {
            if l2.id.is_some() {
                let method =
                    Self::ident_to_http_method(l2.id.as_ref().unwrap())?;
                for attr in &l2.attrs {
                    let mut filter = false;
                    let attr_id_str = attr.id.to_string();
                    match attr_id_str.as_str() {
                        "allow" => (),
                        "filter" => filter = true,
                        _ => {
                            return Err(syn_error(&format!(
                                "unknown authorization attribute: {}",
                                attr_id_str,
                            )));
                        }
                    }
                    authorizers.insert(
                        method,
                        Authorizer {
                            priority,
                            pattern: pattern.clone(),
                            roles: attr.val.get_id_strings()?,
                            filter,
                        },
                    );
                }
            } else {
                for attr in &l2.attrs {
                    authorizers.insert(
                        Self::ident_to_http_method(&attr.id)?,
                        Authorizer {
                            priority,
                            pattern: pattern.clone(),
                            roles: attr.val.get_id_strings()?,
                            filter: false,
                        },
                    );
                }
            }
        }
        Ok(())
    }

    // assumes level_1 to be NotFound
    fn get_not_found(
        &self,
        not_found: &mut Option<(Path, Ident)>,
    ) -> syn::Result<()> {
        Ok(*not_found = Some((
            self.value
                .as_ref()
                .ok_or_else(|| syn_error("missing not_found controller Path"))
                .and_then(|v| v.get_path())?,
            self.level_2
                .first()
                .and_then(|l2| l2.id.clone())
                .ok_or_else(|| {
                    syn_error("missing not_found function Ident")
                })?,
        )))
    }

    // assumes level_1 to be PlugIn
    fn get_plug_in(
        &self,
        plug_ins: &mut HashMap<String, (Type, Expr)>,
    ) -> syn::Result<()> {
        let id = self
            .value
            .as_ref()
            .ok_or_else(|| syn_error("missing plug in identifier"))
            .and_then(|path| path.get_ident().map(|id| id.to_string()))?;
        let l2 = self
            .level_2
            .first()
            .ok_or_else(|| syn_error("missing plug in attributes"))?;
        plug_ins.insert(
            id,
            l2.attrs
                .iter()
                .find(|ci| ci.id.to_string() == "def")
                .ok_or_else(|| syn_error("missing plug in attribute 'def'"))?
                .val
                .get_type_expr()?,
        );
        Ok(())
    }

    // assumes level_1 to be Routes
    fn get_routes(
        &self,
        routes: &mut Vec<(Path, Handler)>,
    ) -> syn::Result<()> {
        use case::CaseExt;
        let contr_path = self
            .value
            .as_ref()
            .ok_or_else(|| syn_error("missing route controller path"))
            .and_then(|v| v.get_path())?;
        let contr_id = &contr_path.segments.last().unwrap().ident.clone();
        let contr_id_snake = contr_id.to_string().to_snake();
        for l2 in &self.level_2 {
            let contr_method: Ident = l2
                .id
                .clone()
                .ok_or_else(|| syn_error("missing route handler function"))?;
            let mut http_method = HttpMethod::Get;
            let mut route_str: Option<&str> = None;
            match contr_method.to_string().as_str() {
                "new_form" => route_str = Some("new"),
                "copy_form" => route_str = Some("<id>/copy"),
                "create" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("");
                }
                "ensure" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("ensure");
                }
                "index" => route_str = Some(""),
                "show" => route_str = Some("<id>"),
                "edit_form" => route_str = Some("<id>/edit"),
                "patch" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("<id>");
                }
                "replace" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("<id>/replace");
                }
                "delete" => {
                    http_method = HttpMethod::Post;
                    route_str = Some("<id>/delete");
                }
                _ => (),
            }
            let mut route = route_str.map(|s| s.to_string());
            for attr in &l2.attrs {
                let attr_nam = attr.id.to_string();
                match attr_nam.as_str() {
                    "http_method" => {
                        http_method = attr.val.get_ident().and_then(|i| {
                            HttpMethod::try_from(i.to_string().as_str())
                                .map_err(|e| syn_error(&e.to_string()))
                        })?;
                    }
                    "path" => {
                        let mut s = attr.val.get_string()?;
                        if 1 < s.len() && s.chars().last() == Some('/') {
                            s.remove(s.len() - 1);
                        }
                        route = Some(s);
                    }
                    _ => {
                        return Err(syn_error(&format!(
                            "unknown handler attribute {}",
                            &attr_nam,
                        )));
                    }
                }
            }
            let route = {
                let mut r = match route {
                    Some(r) => r,
                    None => return Err(syn_error("missing path")),
                };
                if !r.starts_with('/') {
                    if !r.is_empty() {
                        r.insert(0, '/');
                    }
                    r.insert_str(0, &contr_id_snake);
                    r.insert(0, '/');
                }
                r
            };
            let route_par_names = get_route_pars(&route);
            routes.push((
                contr_path.clone(),
                Handler {
                    authorized: None,
                    contr_method,
                    http_method,
                    route,
                    route_par_names,
                },
            ));
        }
        Ok(())
    }

    // assumes level_1 to be StaticRoutes
    fn get_static_routes(
        &self,
        routes: &mut Vec<(String, String)>,
    ) -> syn::Result<()> {
        use crate::fix_slashes;
        if let Some(v) = &self.value {
            let url_path = v.get_fix_slashes(1, -1)?;
            let mut fs_path = None;
            if let Some(l2) = self.level_2.first() {
                if let Some(attr) = l2.attrs.first() {
                    if attr.id.to_string() == "fs_path" {
                        fs_path = Some(attr.val.get_fix_slashes(0, -1)?);
                    } else {
                        return Err(syn_error(
                            "Expecting route_static(...) { fs_path: \"...\" }"
                        ));
                    }
                }
            }
            let fs_path = fix_slashes(
                &fs_path.unwrap_or(fix_slashes(&url_path, -1, 0)),
                0,
                -1,
            );
            routes.push((url_path, fs_path));
            Ok(())
        } else {
            Err(syn_error("Expecting route_static(\"...\")"))
        }
    }

    fn ident_to_http_method(id: &Ident) -> syn::Result<HttpMethod> {
        HttpMethod::try_from(id.to_string().as_str())
            .map_err(|e| syn_error(&e.to_string()))
    }
}

impl Parse for ConfigItem {
    fn parse(stream: ParseStream) -> syn::Result<Self> {
        let level_1: ConfigItemId = {
            let id = stream.parse::<Ident>()?.to_string();
            match id.as_str() {
                "app_config" => ConfigItemId::AppConfig,
                "authorize" => ConfigItemId::Authorize,
                "not_found" => ConfigItemId::NotFound,
                "plug_in" => ConfigItemId::PlugIn,
                "route" => ConfigItemId::Routes,
                "route_static" => ConfigItemId::StaticRoutes,
                _ => {
                    return Err(syn_error(&format!(
                        "'{}' cannot start a Config item",
                        &id
                    )));
                }
            }
        };
        let value: Option<ConfigAttrVal> = if stream.peek(token::Paren) {
            let content;
            parenthesized!(content in stream);
            if content.is_empty() {
                None
            } else {
                Some(content.parse()?)
            }
        } else {
            None
        };
        let mut level_2: Vec<Level2> = Vec::new();
        if stream.peek(token::Brace) {
            if {
                let fork = stream.fork();
                let content;
                braced!(content in fork);
                content.peek(Ident) && content.peek2(token::Colon)
            } {
                // only lev 3
                level_2.push(Level2 {
                    id: None,
                    attrs: get_config_attrs(stream)?,
                });
            } else {
                let content;
                braced!(content in stream);
                level_2 = content
                    .parse_terminated::<Level2, token::Comma>(Level2::parse)?
                    .into_iter()
                    .collect();
            }
        }
        Ok(Self {
            level_1,
            value,
            level_2,
        })
    }
}

impl Parse for ConfigAttrVal {
    fn parse(stream: ParseStream) -> syn::Result<Self> {
        use std::mem::discriminant;
        if stream.peek(token::Paren) {
            let content;
            parenthesized!(content in stream);
            let ty: Type = content.parse()?;
            content.parse::<token::Comma>()?;
            let expr: Expr = content.parse()?;
            let _ = content.parse::<token::Comma>();
            return Ok(Self::TypeExpr(ty, expr));
        }
        if stream.peek(token::Bracket) {
            let content;
            bracketed!(content in stream);
            return Ok(Self::Arr({
                let mut arr = Vec::new();
                let mut element_variant = None;
                for val in content
                    .parse_terminated::<ConfigAttrVal, token::Comma>(
                        ConfigAttrVal::parse,
                    )?
                {
                    let this_variant = discriminant(&val);
                    if let Some(dscr) = element_variant {
                        if this_variant != dscr {
                            return Err(syn_error(
                                "array elements must all be the same \
                                variant",
                            ));
                        }
                    } else {
                        element_variant = Some(this_variant)
                    }
                    arr.push(val);
                }
                arr
            }));
        }
        let expr: Expr = stream.parse()?;
        match &expr {
            Expr::Lit(lit) => match &lit.lit {
                syn::Lit::Bool(b) => return Ok(Self::Bool(b.clone())),
                syn::Lit::Char(c) => return Ok(Self::Char(c.clone())),
                syn::Lit::Float(f) => return Ok(Self::Float(f.clone())),
                syn::Lit::Int(i) => return Ok(Self::Int(i.clone())),
                syn::Lit::Str(s) => return Ok(Self::Str(s.clone())),
                _ => (),
            },
            Expr::Path(p) => {
                return Ok(p
                    .path
                    .get_ident()
                    .map(|i| Self::Ident(i.clone()))
                    .unwrap_or_else(|| Self::Path(p.path.clone())))
            }
            _ => (),
        }
        Err(syn_error(&format!(
            "cannot handle attribute value '{}'",
            tokens_to_string(&expr.clone()),
        )))
    }
}

#[derive(Clone, Debug)]
struct Authorizer {
    priority: usize,
    pattern: Regex,
    roles: Vec<String>,
    filter: bool,
}

impl Eq for Authorizer {}

impl Ord for Authorizer {
    fn cmp(&self, other: &Self) -> Ordering {
        other.priority.cmp(&self.priority) // sic!
    }
}

impl PartialEq for Authorizer {
    fn eq(&self, other: &Self) -> bool {
        self.priority == other.priority
    }
}

impl PartialOrd for Authorizer {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

struct Authorizers(HashMap<HttpMethod, Vec<Authorizer>>);

impl Authorizers {
    fn new() -> Self {
        Self(HashMap::new())
    }

    fn get(&self, method: HttpMethod) -> syn::Result<&[Authorizer]> {
        Ok(self
            .0
            .get(&method)
            .ok_or_else(|| {
                syn_error(&format!(
                    "no authorizations for HTTP method {}",
                    method.to_string()
                ))
            })?
            .as_slice())
    }

    fn insert(&mut self, method: HttpMethod, authorizer: Authorizer) {
        match self.0.get_mut(&method) {
            Some(auths) => auths.push(authorizer),
            None => {
                self.0.insert(method, vec![authorizer]);
            }
        }
    }

    // Resolve all pseudo roles except `Public`, which is handled later.
    // Sort.
    fn sanitize(&mut self, defined_roles: &[String]) -> syn::Result<()> {
        let enabled: Vec<String> = defined_roles
            .iter()
            .filter(|r| r.as_str() != "Disabled")
            .map(|r| r.clone())
            .collect();
        for (_, auths) in &mut self.0 {
            for auth in auths.iter_mut() {
                for role in &auth.roles {
                    match role.as_str() {
                        "Authenticated" => {
                            Self::assert_single(
                                &role,
                                auth.roles.as_slice(),
                            )?;
                            auth.roles = defined_roles.to_vec();
                            break;
                        }
                        "Enabled" => {
                            Self::assert_single(
                                &role,
                                auth.roles.as_slice(),
                            )?;
                            auth.roles = enabled.clone();
                            break;
                        }
                        "Public" => {
                            Self::assert_single(
                                &role,
                                auth.roles.as_slice(),
                            )?;
                            break;
                        }
                        _ if defined_roles.contains(&role) => (),
                        _ => {
                            return Err(syn_error(&format!(
                                "{} is not a role",
                                role
                            )));
                        }
                    }
                }
            }
            auths.sort();
        }
        Ok(())
    }

    fn assert_single(role: &str, roles: &[String]) -> syn::Result<()> {
        if roles.len() == 1 {
            return Ok(());
        }
        Err(syn_error(&format!("{} should be the only role", role)))
    }
}

#[derive(Clone, Debug)]
struct Level2 {
    id: Option<Ident>,
    attrs: Vec<ConfigAttr>,
}

impl Parse for Level2 {
    fn parse(stream: ParseStream) -> syn::Result<Self> {
        Ok(Self {
            id: stream.parse()?,
            attrs: get_config_attrs(stream)?,
        })
    }
}

fn get_config_attrs(stream: ParseStream) -> syn::Result<Vec<ConfigAttr>> {
    Ok(if stream.peek(token::Brace) {
        let content;
        braced!(content in stream);
        content
            .parse_terminated::<ConfigAttr, token::Comma>(ConfigAttr::parse)?
            .into_iter()
            .collect()
    } else {
        Vec::new()
    })
}

#[derive(Clone, Debug)]
struct ConfigAttr {
    id: Ident,
    val: ConfigAttrVal,
}

impl Parse for ConfigAttr {
    fn parse(stream: ParseStream) -> syn::Result<Self> {
        let id: Ident = stream.parse()?;
        stream.parse::<token::Colon>()?;
        Ok(Self {
            id,
            val: stream.parse()?,
        })
    }
}

fn syn_error(e: &str) -> syn::Error {
    syn::Error::new(proc_macro2::Span::call_site(), e)
}

#[cfg(test)]
mod tests {
    // TODO: unit test Config::parse()
    use super::*;
    use serde_json::json;

    #[test]
    fn test_formdata() {
        assert_eq!(
            serde_json::to_value(
                FormData::parse(
                    vec![
                        ("smpl", "1"),
                        ("arr[]", "2"),
                        ("arr[]", "3"),
                        ("map[a]", "4"),
                        ("map[b]", "5"),
                        ("deep[c][]", "6"),
                        ("deep[c][]", "7"),
                        ("deep[d]", "8"),
                        ("mtrx[][]", "9"),
                    ]
                    .iter()
                    .map(|(k, v)| (k.to_string(), v.to_string()))
                    .collect(),
                )
                .unwrap(),
            )
            .unwrap(),
            json!({
                "smpl": "1",
                "arr":  ["2", "3"],
                "map":  { "a": "4", "b": "5" },
                "deep": { "c": ["6", "7"], "d": "8" },
                "mtrx": [["9"]],
            }),
        );
    }
}
