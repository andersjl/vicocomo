//! A trait and helper types to communicate to and from HTML forms.
//!
//#![allow(dead_code)]

use super::utils::*;
use crate::{texts::get_text, Error, HttpServerIf, SessionModel};
use ljumvall_utils::blacken;
use serde::{Deserialize, Serialize};
use serde_json::value::{Map as JsonMap, Value as JsonValue};
use std::{
    fmt::{Debug, Display},
    str::FromStr,
    string::ToString,
};

// --- HtmlInput -------------------------------------------------------------

/// A tag or tags for input in an HTML `form`.
///
/// To keep track of the various HTML form input elements, a read-only
/// [`InputType`](enum.InputType.html) is set on creation.
///
/// `V` is the type of the value that is rendered and retrieved. (For the
/// multiple selection variants [`Checkbox`
/// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
/// ](enum.InputType.html#variant.SelectMult) it is the type of the elements
/// in the array of selected values.)
///
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct HtmlInput<V> {
    embed: Vec<HtmlTag>,
    // if Some(_), render() will add this class unless errs.is_empty()
    err_cls: Option<String>,
    // localized by render()
    errs: Vec<String>,
    // the tag label if any, localized by render()
    lab: Option<String>,
    // the String is localized by render()
    opts: Vec<(String, V)>,
    // first option w/o value in select tag, localized by render()
    prpt: Option<String>,
    // if we render more than one tag, this is a template, see render()
    tag: HtmlTag,
    typ: InputType,
    vals: Vec<V>,
}

impl<V> HtmlInput<V>
where
    V: Clone + Debug + Display + FromStr + PartialEq,
    <V as FromStr>::Err: Display,
{
    /// Create an empty object with the `ty` variant of [`InputType`
    /// ](enum.InputType.html).
    ///
    /// `name` is the input name.
    ///
    pub fn new(ty: InputType, name: &str) -> Self {
        Self {
            embed: Vec::new(),
            err_cls: Some("vicocomo_errors".to_string()),
            errs: Vec::new(),
            lab: None,
            opts: Vec::new(),
            prpt: None,
            tag: ty.tag(name),
            typ: ty,
            vals: Vec::new(),
        }
    }

    /// Add one (or more, whitespace separated) value(s) to an HTML attribute
    /// for the generated tag(s), see [`render()`](#method.render).
    ///
    /// For details see [`HtmlTag::add_attr_vals()`
    /// ](../utils/struct.HtmlTag.html#method.add_attr_vals).
    ///
    pub fn add_attr_vals(&mut self, attr: &str, values: &str) {
        self.tag.add_attr_vals(attr, values);
    }

    /// Make [`render()`](#method.render) output the (each) input as inner
    /// HTML to `embedding`.
    ///
    /// Repeted calls add more embedding.
    ///
    pub fn add_embedding(&mut self, embedding: HtmlTag) {
        self.embed.push(embedding);
    }

    /// Append error text lines formatted from an error, see
    /// [`Error::to_strings()`
    /// ](../../error/enum.Error.html#method.to_strings). See also [`render()`
    /// ](#method.render).
    ///
    /// <small>Does nothing for the variant [`Error::Model`
    /// ](../../error/enum.Error.html#variant.Model), which should be
    /// added to the [`HtmlForm`](trait.HtmlForm.html#tymethod.add_error)
    /// containing `self`!</small>
    ///
    pub fn add_error(&mut self, error: &Error) {
        match error {
            Error::Model(_) => (),
            _ => {
                for line in error.to_strings() {
                    self.errs.push(line);
                }
            }
        }
    }

    /// Append an error text without formatting. See[`render()`
    /// ](#method.render).
    ///
    pub fn add_error_text<T: ToString + ?Sized>(&mut self, error: &T) {
        self.errs.push(error.to_string())
    }

    /// Clear the value, after which `get()` returns `None` and `get_mult()`
    /// returns an empty vector.
    ///
    pub fn clear(&mut self) {
        self.vals.clear();
    }

    /// Clear all errors generated by [`update()`](#method.update) or set by
    /// [`add_error()`](#method.add_error), [`add_error_text()`
    /// ](#method.add_error_text), or [`prepend_error()`
    /// ](#method.prepend_error). See [`render()`](#method.render).
    ///
    pub fn clear_errors(&mut self) {
        self.errs.clear();
    }

    /// Clear the label. See [`render()`](#method.render).
    ///
    pub fn clear_label(&mut self) {
        self.lab = None;
    }

    /// Get the current value.
    ///
    /// <b>Note:</b> This method returns at most one value for the variants
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult). Use [`get_mult()`
    /// ](#method.get_mult) to get all values.
    ///
    pub fn get(&self) -> Option<V> {
        if self.vals.is_empty() {
            None
        } else {
            Some(self.vals.first().unwrap().clone())
        }
    }

    /// Get all stored values.
    ///
    /// <b>Note:</b> For all except the multiple selection variants
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) this function never returns
    /// more than one value.
    ///
    pub fn get_mult(&self) -> Vec<V> {
        self.vals.clone()
    }

    /// Get a clone of the tag that will be used by [`render()`
    /// ](#method.render).
    ///
    pub fn get_tag(&self) -> HtmlTag {
        self.tag.clone()
    }

    /// The [type](enum.InputType.html) of the input.
    ///
    /// For the types that are rendered as one or more `input` tags this is
    /// the (capitalized) value of the `type` attribute. The exceptions are
    /// `Select`, `SelectMult`, and `Textarea`.
    ///
    pub fn get_type(&self) -> InputType {
        self.typ
    }

    /// Equivalent to `self.iter_error().next().is_some()`.
    ///
    pub fn has_errors(&self) -> bool {
        !self.errs.is_empty()
    }

    /// Iterate over all stored values.
    ///
    /// <b>Note:</b> For all except the multiple selection variants
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) the iterator never yields
    /// more than one value.
    ///
    pub fn iter(&self) -> std::slice::Iter<'_, V> {
        self.vals.iter()
    }

    /// Iterate over all errors generated by [`update()`](#method.update) or
    /// set by [`add_error()`](#method.add_error), [`add_error_text()`
    /// ](#method.add_error_text), or [`prepend_error()`
    /// ](#method.prepend_error).
    ///
    pub fn iter_error(&self) -> std::slice::Iter<'_, String> {
        self.errs.iter()
    }

    /// Prepend an error to the list of errors.
    ///
    pub fn prepend_error(&mut self, error: &str) {
        if self.errs.first().map(|e| e != error).unwrap_or(true) {
            self.errs.insert(0, error.to_string());
        }
    }

    /// Output a data structure to facilitate [rendering
    /// ](../../http/server/struct.TemplEngIf.html#method.render) the field.
    /// See the [example](#example).
    ///
    /// The output is a JSON `Object` that has two keys, `"errors"` and
    /// `"data"`.
    ///
    /// ## `"errors":`
    ///
    /// This is a JSON `Array` of JSON `String`s as generated by [`update()`
    /// ](#method.update) or set by [`add_error()`](#method.add_error),
    /// [`add_error_text()`](#method.add_error_text), or [`prepend_error()`
    /// ](#method.prepend_error)
    ///
    /// The JSON `String`s are [localized](../texts/index.html).
    ///
    /// ## `"data":`
    ///
    /// This is a JSON `Object` (or, for [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio), a JSON `Array` of them).
    ///
    /// Each `Object` has two keys, `"label"` and `"tag"`.
    ///
    /// The <b>tag</b> is a JSON `String`. It inlcudes inner HTML and end tag
    /// for [`Select`](enum.InputType.html#variant.Select), [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult), and [`Textarea`
    /// ](enum.InputType.html#variant.Textarea). If the input is embedded (see
    /// [`add_embedding()`](#method.add_embedding)), the embedding is repeated
    /// for each tag generated for [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio).
    ///
    /// The `id` attribute of the generated tag is as set with
    /// [`set_attr("id", _)`](#method.set_attr). If not set, the default is
    /// the [name](#method.new). For [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio) the [value](#method.set_options)
    /// is appended to get a unique `id` for each `input` tag.
    ///
    /// For the multple-valued input types [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult), `"[]" is appended to the
    /// `name` attribute of the generated tag. This makes
    /// [`HttpServerIf::param_json()`
    /// ](../../http/server/struct.HttpServerIf.html#method.param_json)
    /// collect the values in a `Json` array.
    ///
    /// If the [`errors`](#errors) array is not empty and
    /// [`set_errors_class(None)`](#method.set_errors_class) has not been
    /// called, the errors class is added to the tag(s) with the value(s).
    ///
    /// The <b>label</b> is as set by [`set_label()`](#method.set_label)
    /// except for [`Checkbox`](enum.InputType.html#variant.Checkbox) and
    /// [`Radio`](enum.InputType.html#variant.Radio) where the labels are
    /// taken from the [options](#method.set_options). For all types the
    /// resulting label text is [localized](../texts/index.html).
    ///
    /// <small>Known bug: An option text that is user input is erronously
    /// localized *if it coincides with a localization key*.</small>
    ///
    /// If no label is set, the label will be JSON `null`. To get labels for
    /// checkboxes and radio buttons you need to [`set_label("")`
    /// ](#method.set_label).
    ///
    /// ### `input` tags
    ///
    /// For those, the `type` attribute is set according to the [`InputType`
    /// ](#method.new). The `value` is as set by [`set()`](#method.set).
    /// Again, the exceptions are [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio) where the `value` is taken from
    /// the [options](#method.set_options).
    ///
    /// Other HTML attributes set by [`add_attr_vals()`
    /// ](#method.add_attr_vals) or [`set_attr()`](#method.set_attr) also go
    /// to (all) `input` tags.
    ///
    /// ### `select` tag
    ///
    /// For [`Select`](enum.InputType.html#variant.Select) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult), the `option` texts and
    /// values are taken from the [options](#method.set_options). The option
    /// texts are [localized](../texts/index.html).
    ///
    /// HTML attributes set by [`add_attr_vals()`](method.add_attr_vals) or
    /// [`set_attr()`](#method.set_attr) go to the `select` tag.
    ///
    /// ### `textarea` tag
    ///
    /// For [`Textarea`](enum.InputType.html#variant.Textarea), the value,
    /// attributes, and (if set) label are rendered in the obvious way.
    ///
    /// ## Example
    /// ```
    /// use chrono::NaiveDate;
    /// use serde_json::json;
    /// use vicocomo::{Error, HtmlInput, InputType};
    ///
    /// let mut input: HtmlInput<NaiveDate> =
    ///     HtmlInput::new(InputType::Date, "dat");
    /// input.set_attr("id", Some("some-id"));
    /// input.set("2020-02-02".parse().unwrap());
    /// input.add_attr_vals("class", " a");
    /// input.add_attr_vals("class", "b c \n");
    ///
    /// assert_eq!(
    ///     input.render(),
    ///     json!({
    ///         "errors": [],
    ///         "data": {
    ///             "label": null,
    ///             "tag": concat!(
    ///                 r#"<input type="date" id="some-id" name="dat""#,
    ///                 r#" value="2020-02-02" class="a b c">"#,
    ///             ),
    ///         },
    ///     }),
    /// );
    ///
    /// let mut with_label_and_error_texts = input.clone();
    /// with_label_and_error_texts.set_label("some-label");
    /// with_label_and_error_texts.add_error_text("some-error");
    /// with_label_and_error_texts.add_error_text("another");
    /// assert_eq!(
    ///     with_label_and_error_texts.render(),
    ///     json!({
    ///         "errors": ["some-error", "another"],
    ///         "data": {
    ///             "label": r#"<label for="some-id">some-label</label>"#,
    ///             "tag": concat!(
    ///                 r#"<input type="date" id="some-id" name="dat""#,
    ///                 r#" value="2020-02-02" class="a b c vicocomo_errors">"#,
    ///             ),
    ///         },
    ///     }),
    /// );
    ///
    /// let mut with_formatted_error = input.clone();
    /// with_formatted_error.add_error(
    ///     &Error::database(Some("12345"), "some-db-error"),
    /// );
    /// assert_eq!(
    ///     with_formatted_error.render(),
    ///     json!({
    ///         "errors": ["error--Database", "error--Database--12345--some-db-error"],
    ///         "data": {
    ///             "label": null,
    ///             "tag": concat!(
    ///                 r#"<input type="date" id="some-id" name="dat""#,
    ///                 r#" value="2020-02-02" class="a b c vicocomo_errors">"#,
    ///             ),
    ///         },
    ///     }),
    /// );
    /// ```
    pub fn render(&self) -> JsonValue {
        match self.typ {
            InputType::Checkbox | InputType::Radio => self.rend_tags(),
            _ => self.rend_tag(),
        }
    }

    /// Set the current value, e.g. to initialize before `render()`ing.
    ///
    /// For the variants [`Radio`](enum.InputType.html#variant.Radio) and
    /// [`Select`](enum.InputType.html#variant.Select) the `value` is removed
    /// if it is not one of the options as set by [`set_options()`
    /// ](#method.set_options).
    ///
    /// <b>Note:</b> This method removes all values except `value` from the
    /// multiple selection variants [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult). Use [`set_mult()`
    /// ](#method.get_mult) to set more than one value.
    ///
    pub fn set(&mut self, value: V) {
        self.vals.clear();
        self.vals.push(value);
        self.sanitize();
    }

    /// Set an attribute value for the generated HTML fragment, see
    /// [`render()`](#method.render).
    ///
    /// For details see [`HtmlTag::set_attr()`
    /// ](../utils/struct.HtmlTag.html#method.set_attr).
    ///
    pub fn set_attr(&mut self, attr: &str, values: Option<&str>) {
        self.tag.set_attr(attr, values);
    }

    /// Add this class in the tags generated by [`render()`](#method.render)
    /// if `self.has_errors()`.
    ///
    /// `None` turns off error class rendering.
    ///
    /// The default is `Some("vicocomo_errors")`.
    ///
    pub fn set_errors_class(&mut self, cls: Option<&str>) {
        self.err_cls = cls.map(|s| s.to_string());
    }

    /// Set the label to use when [rendering](#method.render) the generated
    /// HTML fragment. If this method is never called, no label(s) will be
    /// generated.
    ///
    pub fn set_label(&mut self, label: &str) {
        self.lab = Some(label.to_string());
    }

    /// Set the stored values in the multiple selection variants [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.Checkbox).
    ///
    /// Silently removes any element in `values` that is not among the
    /// [set options](#method.set_options).
    ///
    /// <b>Note:</b> ignores all `values` except the first for other variants.
    ///
    pub fn set_mult(&mut self, values: &[V]) {
        self.vals.clear();
        self.vals.extend_from_slice(values);
        self.sanitize();
    }

    /// Set the available options in the selection types [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox), [`Radio`
    /// ](enum.InputType.html#variant.Radio), [`Select`
    /// ](enum.InputType.html#variant.Select), and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult).
    ///
    /// `options` is a slice of pairs of option text and option value. For
    /// [`Checkbox`](enum.InputType.html#variant.Checkbox) and [`Radio`
    /// ](enum.InputType.html#variant.Radio) the text goes to the labels, for
    /// [`Select`](enum.InputType.html#variant.Select) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) they go to `option`'s inner
    /// HTML.
    ///
    /// The texts are [localized](../texts/index.html) by [`render()`
    /// ](#method.render).
    ///
    /// <small>Known bug: An option text that is user input is erronously
    /// localized *if it coincides with a localization key*.</small>
    ///
    /// Also silently removes all existing values that are not in the new
    /// option set.
    ///
    /// <b>Note:</b> This method is meaningless for other variants.
    ///
    pub fn set_options(&mut self, options: &[(&str, V)]) {
        self.opts.clear();
        self.opts
            .extend(options.iter().map(|(s, v)| (s.to_string(), v.clone())));
        self.sanitize();
    }

    /// Set the text shown in the field for select tags [`Select`
    /// ](enum.InputType.html#variant.Select) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) when no option is selected.
    ///
    /// `prompt` is the prompt to use, `None` meaning no prompt (the default).
    /// `Some("")` means that the field is blank if no option is selected.
    ///
    /// The prompt is [localized](../texts/index.html) by [`render()`
    /// ](#method.render).
    ///
    /// <b>Note:</b> This method is meaningless for other variants.
    ///
    pub fn set_prompt(&mut self, prompt: Option<&str>) {
        self.prpt = prompt.map(|p| p.to_string());
        self.sanitize();
    }

    /// Set the available options in select tags like [`set_options()`
    /// ](#method.set_options) and the prompt like [`set_prompt()`
    /// ](#method.set_prompt), see those.
    ///
    pub fn set_prompted_options(
        &mut self,
        prompt: &str,
        options: &[(&str, V)],
    ) {
        self.prpt = Some(prompt.to_string());
        self.opts.clear();
        self.opts
            .extend(options.iter().map(|(s, v)| (s.to_string(), v.clone())));
        self.sanitize();
    }

    /// Update `self` from a JSON value.
    ///
    /// For the multiple selection variants [`Checkbox`
    /// ](enum.InputType.html#variant.Checkbox) and [`SelectMult`
    /// ](enum.InputType.html#variant.SelectMult) the `json` should be a JSON
    /// array of JSON strings. For other variants it should be a JSON string.
    ///
    /// If conversion fails, keep the old value(s) and return an error. The
    /// failure may be because the string cannot be parsed as the field's Rust
    /// type, or because the field is one of the selection types and a value
    /// in `json` is not among the current [options](#method.set_options).
    ///
    /// On error, one or more error messages are stored in [`self`
    /// ](#method.iter_error), an error message `"update"` is prepended to
    /// them, and the returned error is `InvalidInput("update")`.
    ///
    pub fn update(&mut self, json: &JsonValue) -> Result<(), Error> {
        match self.typ {
            InputType::Checkbox | InputType::SelectMult => {
                self.parse_json_arr(json)
            }
            _ => self.parse_json_str(json).map(|v| vec![v]),
        }
        .and_then(|received_vals| {
            let old_vals = self.vals.clone();
            let received_len = received_vals.len();
            self.vals = received_vals;
            self.sanitize();
            if self.vals.len() == received_len {
                Some(())
            } else {
                self.vals = old_vals;
                self.errs.insert(0, json.to_string());
                None
            }
        })
        .ok_or_else(|| {
            self.errs.insert(0, "update".to_string());
            Error::invalid_input("update")
        })
    }

    // - - private - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    fn parse_json_arr(&mut self, json: &JsonValue) -> Option<Vec<V>> {
        if let JsonValue::Array(arr) = json {
            let mut result = Vec::new();
            for leaf in arr {
                if let Some(val) = self.parse_json_str(leaf) {
                    result.push(val);
                }
            }
            if self.errs.is_empty() {
                Some(result)
            } else {
                None
            }
        } else {
            self.errs.push(json.to_string());
            None
        }
    }

    fn parse_json_str(&mut self, json: &JsonValue) -> Option<V> {
        if let JsonValue::String(s) = json {
            s.parse::<V>()
                .map_err(|e| {
                    self.errs.push(s.to_string());
                    self.errs.push(e.to_string());
                    e
                })
                .ok()
        } else {
            self.errs.push(json.to_string());
            None
        }
    }

    fn rend_errs(&self) -> JsonValue {
        JsonValue::Array(
            self.errs
                .iter()
                .map(|e| JsonValue::String(get_text(&e.to_string(), &[])))
                .collect(),
        )
    }

    fn rend_label(tag: &HtmlTag, lab: Option<&str>) -> JsonValue {
        lab.map(|l| {
            JsonValue::String(format!(
                "<label for=\"{}\">{}</label>",
                &tag.get_attr_first("id").unwrap(),
                &get_text(l, &[]),
            ))
        })
        .unwrap_or(JsonValue::Null)
    }

    fn rend_tag(&self) -> JsonValue {
        let mut result = JsonMap::new();
        result.insert("errors".to_string(), self.rend_errs());
        result.insert(
            "data".to_string(),
            self.rend_tag_do(self.lab.as_deref(), &self.tag),
        );
        JsonValue::Object(result)
    }

    // panics if tag has no "id" attribute
    fn rend_tag_do(&self, lab: Option<&str>, tag: &HtmlTag) -> JsonValue {
        let mut result = JsonMap::new();
        result.insert("label".to_string(), Self::rend_label(tag, lab));
        result.insert(
            "tag".to_string(),
            JsonValue::String({
                let mut cloned = tag.clone();
                let errors = !self.errs.is_empty() && self.err_cls.is_some();
                let embed = !self.embed.is_empty();
                if let InputType::SelectMult = self.typ {
                    cloned.set_attr(
                        "name",
                        Some(
                            &(cloned.get_attr_first("name").unwrap() + "[]"),
                        ),
                    );
                }
                if errors || embed {
                    if errors {
                        cloned.add_attr_vals(
                            "class",
                            self.err_cls.as_ref().unwrap(),
                        );
                    }
                    for embedding in &self.embed {
                        let mut embedding = embedding.clone();
                        embedding.push_tag(cloned);
                        cloned = embedding;
                    }
                }
                cloned.to_string()
            }),
        );
        JsonValue::Object(result)
    }

    // panics if self.tag has no "id" or "name" attributes
    fn rend_tags(&self) -> JsonValue {
        let id = self.tag.get_attr_first("id").unwrap();
        let mut result = JsonMap::new();
        result.insert("errors".to_string(), self.rend_errs());
        let mut inputs = Vec::new();
        for (lab, val) in &self.opts {
            let mut tag = self.tag.clone();
            tag.set_attr(
                "id",
                Some(&(id.clone() + "--" + &blacken(&val.to_string()))),
            );
            if let InputType::Checkbox = self.typ {
                tag.set_attr(
                    "name",
                    Some(&(tag.get_attr_first("name").unwrap() + "[]")),
                );
            }
            tag.set_attr("value", Some(&val.to_string()));
            if self.vals.contains(&val) {
                tag.set_attr("checked", None);
            }
            inputs.push(self.rend_tag_do(
                // use the presence of *self.lab* as a flag to render *lab*
                self.lab.as_ref().map(|_| lab.as_str()),
                &tag,
            ));
        }
        result.insert("data".to_string(), JsonValue::Array(inputs));
        JsonValue::Object(result)
    }

    fn sanitize(&mut self) {
        // mutliple values only for the multiple selection variants
        match self.typ {
            InputType::Checkbox | InputType::SelectMult => (),
            _ => self.vals.truncate(1),
        }
        match self.typ {
            // for checkbox, radio, and select, remove vals not in opts
            InputType::Checkbox
            | InputType::Radio
            | InputType::Select
            | InputType::SelectMult => {
                let opts = &self.opts;
                self.vals
                    .retain(|v| opts.iter().find(|(_, o)| o == v).is_some());
            }
            // for textarea, no opts, sync tag text with vals
            InputType::Textarea => {
                self.opts = Vec::new();
                self.tag.clear_inner();
                match self.vals.first() {
                    Some(val) => self.tag.push_text(&val.to_string()),
                    _ => (),
                }
            }
            // for other types, no opts, sync tag value with vals
            _ => {
                self.opts = Vec::new();
                match self.vals.first() {
                    Some(v) => {
                        self.tag.set_attr("value", Some(&v.to_string()));
                    }
                    None => self.tag.drop_attr("value"),
                }
            }
        }
        match self.typ {
            // for select types, set tag options
            InputType::Select | InputType::SelectMult => {
                self.tag.clear_inner();
                if let Some(p) = self.prpt.as_ref() {
                    self.tag.push_tag(Self::make_option("", false, p));
                }
                for (txt, val) in &self.opts {
                    self.tag.push_tag(Self::make_option(
                        &val.to_string(),
                        self.vals.contains(&val),
                        txt,
                    ));
                }
            }
            // for other types, no prompt
            _ => self.prpt = None,
        }
    }

    fn make_option(val: &str, sel: bool, txt: &str) -> HtmlTag {
        let mut result = HtmlTag::new("option");
        result.set_attr("value", Some(val));
        if sel {
            result.set_attr("selected", None);
        }
        result.push_text(&get_text(txt, &[]));
        result
    }
}

fn json_error(json: &JsonValue) -> Error {
    Error::invalid_input(json.to_string().as_str())
}

/// The type and current value of a form input, see [`HtmlInput`
/// ](struct.HtmlInput.html).
///
#[derive(Clone, Copy, Debug, Deserialize, Serialize)]
pub enum InputType {
    /// Zero or more `<input type="checkbox" ` ... `>`.
    ///
    /// <b>Note:</b> This variant is error-prone if the stored values are of a
    /// floating point type because of rounding errors when comparing input
    /// values to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    Checkbox,

    /// One `<input type="date" `...` >`
    ///
    Date,

    /// One `<input type="email" `...` >`
    ///
    Email,

    /// One `<input type="file" `...` >`
    ///
    File,

    /// One `<input type="hidden" `...` >`
    ///
    Hidden,

    /// One `<input type="number" `...` >`
    ///
    Number,

    /// One `<input type="password" `...` >`
    ///
    Password,

    /// Zero or more `<input type="radio" `...` >`.
    ///
    /// <b>Note:</b> This variant is error-prone if the stored value is of a
    /// floating point type because of rounding errors when comparing an input
    /// value to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    Radio,

    /// One `<input type="range" `...` >`
    ///
    Range,

    /// One `<input type="search" `...` >`
    ///
    Search,

    /// One `<select `...` > <option `...` > `...` </option> `...` </select>`
    ///
    /// <b>Note:</b> This variant is error-prone if the stored value is of a
    /// floating point type because of rounding errors when comparing an input
    /// value to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    Select,

    /// One `<select `...` multiple> `...` </select>`
    ///
    /// <b>Note:</b> This variant is error-prone if the stored values are of a
    /// floating point type because of rounding errors when comparing input
    /// values to those set by [`set_options`
    /// ](struct.HtmlInput.html#method.set_options).
    ///
    SelectMult,

    /// One `<input type="text" `...` >`
    ///
    Text,

    /// One `<textarea `...` > `...` </textarea>`
    ///
    Textarea,

    /// One `<input type="url" `...` >`
    ///
    Url,
}

impl InputType {
    fn tag(self, name: &str) -> HtmlTag {
        let mut result = match self {
            Self::Checkbox => Self::input_tag("checkbox"),
            Self::Date => Self::input_tag("date"),
            Self::Email => Self::input_tag("email"),
            Self::File => Self::input_tag("file"),
            Self::Hidden => Self::input_tag("hidden"),
            Self::Number => Self::input_tag("number"),
            Self::Password => Self::input_tag("password"),
            Self::Radio => Self::input_tag("radio"),
            Self::Range => Self::input_tag("range"),
            Self::Search => Self::input_tag("search"),
            Self::Text => Self::input_tag("text"),
            Self::Select => HtmlTag::new("select"),
            Self::SelectMult => {
                let mut result = HtmlTag::new("select");
                result.set_attr("multiple", None);
                result
            }
            Self::Textarea => HtmlTag::new("textarea"),
            Self::Url => Self::input_tag("url"),
        };
        result.set_attr("id", Some(name));
        result.set_attr("name", Some(name));
        result
    }

    fn input_tag(typ: &str) -> HtmlTag {
        let mut result = HtmlTag::new("input");
        result.add_attr_vals("type", typ);
        result
    }
}

// --- html_form -------------------------------------------------------------

/// A trait for generating an HTML form and handling the input from it.
///
/// Not intended for manual derive, use the [derive macro
/// ](../../../vicocomo_html_macros/derive.HtmlForm.html).
///
/// ## Examples
///
/// There is a more elaborate example in the `examples/html/html_form`
/// directory.
///
/// ### Inferring or setting input types
/// ```
/// use chrono::NaiveDate;
/// use serde_json::json;
/// use vicocomo::{HtmlForm, HtmlInput};
///
/// #[derive(Clone, HtmlForm)]
/// struct BigForm {                                // Rust type or trait,
/// //------------------------------------------------------------------------
///     // this field is mandatory if deriving
///     errors: Vec<String>,
///     // <input type="number" ... >
///     // Num => default InputType::Number
///     num: HtmlInput<i32>,                        // Num
///     // <input type="range" ... >
///     #[vicocomo_html_input_type = "Range"]
///     rng: HtmlInput<u32>,                        // Num
///     // <input type="text" ... >
///     // String => default InputType::Text
///     lin: HtmlInput<String>,                     // String
///     // <textarea ... > ... </textarea>
///     #[vicocomo_html_input_type = "Textarea"]
///     txt: HtmlInput<String>,                     // String
///     // <input type="hidden" ... >
///     #[vicocomo_html_input_type = "Hidden"]
///     // vicocomo_html_input_type Email, File, Password, Search, Url =>
///     // <input type="email", ...>, ... <input type="url" ...>
///     hid: HtmlInput<String>,                     // String
///     // <input type="date" ... >
///     // NaiveDate => default InputType::Date
///     dat: HtmlInput<NaiveDate>,                  // NaiveDate
///     // <select ... > ... </select>
///     #[vicocomo_html_input_type = "Select"]
///     sel: HtmlInput<u32>,                        // any
///     // <input type="radio" ... > ... one button per set_options() element
///     #[vicocomo_html_input_type = "Radio"]
///     rad: HtmlInput<i32>,                        // any
///     // <select ... multiple> ... </select>
///     #[vicocomo_html_input_type = "SelectMult"]
///     mul: HtmlInput<i64>,                        // any
///     // <input type="checkbox" ... > ... one box per set_options() pair
///     #[vicocomo_html_input_type = "Checkbox"]
///     chk: HtmlInput<String>,                     // any
///     // A field that is largely ignored by the derive macro, but it
///     // HAS TO BE AN Option<_> to be derivable.
///     foo: Option<String>,
/// }
///
/// let mut big = BigForm::new();
///
/// // numeric field
/// big.num.set(17i32);
/// assert_eq!(big.num.get().unwrap(), 17i32);
/// assert!(big.update(&json!({"num": "42"})).is_ok());
/// assert_eq!(big.num.get().unwrap(), 42i32);
///
/// // CheckBox, Radio, Select, and SelectMult need an (option, value) list
/// big.sel.set_prompt(Some("p"));
/// big.sel.set_options(&[("a", 1), ("b", 42)]);
/// big.rad.set_options(&[("a", 1), ("b", -42)]);
/// big.mul.set_options(&[("a", 1), ("b", std::i64::MIN)]);
/// big.chk.set_options(&[("a", "x".to_string()), ("b", "y".to_string())]);
/// assert!(
///     big.update(&json!({
///         "num": "17",
///         "rng": "42",
///         "lin": "line",
///         "txt": "text",
///         "hid": "hidden",
///         "dat": "2020-02-02",
///         "sel": "42",
///         "rad": "-42",
///         "mul": ["-9223372036854775808", "1"],
///         "chk": ["x"],
///     }))
///     .is_ok(),
/// );
/// ```
///
/// ### Rendering
/// ```
/// use serde_json::json;
/// use vicocomo::{HtmlForm, HtmlInput, HtmlTag};
///
/// #[derive(Clone, HtmlForm)]
/// struct SmallForm {
///     errors: Vec<String>,
///     num: HtmlInput<u32>,
///     #[vicocomo_html_input_type = "Radio"]
///     rad: HtmlInput<i32>,
///     #[vicocomo_html_input_type = "SelectMult"]
///     mul: HtmlInput<i64>,
///     foo: Option<String>,
/// }
///
/// let mut small = SmallForm::with_labels(Some("pre"));
///
/// small.rad.set_options(&[("a", 1), ("b", -42)]);
/// small.rad.add_embedding(HtmlTag::new("td"));
/// small.mul.set_options(&[("p", 1), ("z", 0), ("n", -1)]);
///
/// assert!(small
///     .update(&json!({
///         "num": "17",
///         "rad": "-42",
///         "mul": ["-1", "1"],
///     }))
///     .is_ok(),
/// );
///
/// assert_eq!(
///     small.to_json(),
///     json!({
///         "errors": [],
///         "foo": null,
///         "mul": {
///             "errors": [],
///             "data": {
///                 "label": r#"<label for="mul">pre--SmallForm--mul--label</label>"#,
///                 "tag": concat!(
///                     r#"<select multiple id="mul" name="mul[]">"#,
///                     r#"<option value="1" selected>p</option>"#,
///                     r#"<option value="0">z</option>"#,
///                     r#"<option value="-1" selected>n</option>"#,
///                     r#"</select>"#,
///                 ),
///             },
///         },
///         "num": {
///             "errors": [],
///             "data": {
///                 "label": r#"<label for="num">pre--SmallForm--num--label</label>"#,
///                 "tag": r#"<input type="number" id="num" name="num" value="17">"#,
///             },
///         },
///         "rad": {
///             "errors": [],
///             "data": [
///                 {
///                   "label": r#"<label for="rad--1">a</label>"#,
///                   "tag": r#"<td><input type="radio" id="rad--1" name="rad" value="1"></td>"#,
///                 },
///                 {
///                   "label": r#"<label for="rad---42">b</label>"#,
///                   "tag": r#"<td><input type="radio" id="rad---42" name="rad" value="-42" checked></td>"#,
///                 }
///             ],
///         },
///     }),
/// );
/// ```
pub trait HtmlForm: Clone + Sized {
    /// Add the error error messages in `error` to those in the form and its
    /// `HtmlInput` fields.
    ///
    /// For [`Error::Model`](../../error/enum.Error.html#variant.Model) the
    /// field error texts are added by [`HtmlInput::add_error()`
    /// ](struct.HtmlInput.html#method.add_error) to the corresponding field
    /// in `self`, matching the field names in the [`ModelError`
    /// ](../../error/struct.ModelError.html) in `error` with `self`s field
    /// identifiers.
    ///
    /// In case the field names differ, `translate` should contain a pair
    /// `(*name in `error`*`, `*name in `self`*`)`. A field in `error` that
    /// has no match or translation is silently ignored.
    ///
    /// Non-field error texts, and texts from other [`Error`
    /// ](../../error/enum.Error.html) variants, are added by
    /// [`self.add_error_text()`](#tymethod.add_error_text).
    ///
    /// For the formatting of the texts, see the implementation of [`Display`
    /// for `Error`](../../error/enum.Error.html#display-examples).
    ///
    /// ## Example
    /// ```
    /// use serde_json::{json, to_value};
    /// use vicocomo::{model_error, HtmlForm, HtmlInput};
    /// #[derive(Clone, HtmlForm)]
    /// struct ExampleForm {
    ///     errors: Vec<String>,
    ///     fld: HtmlInput<u32>,
    /// }
    /// let mut form = ExampleForm::new();
    /// assert!(form.update(&json!({ "fld": "17" })).is_ok());
    /// assert!(form.update(&json!({ "fld": "fortytwo" })).is_err());
    /// assert_eq!(to_value(form.fld.get_mult()).unwrap(), json!([17]));
    /// assert_eq!(
    ///     form.iter_error().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         &serde_json::to_string(&json!({"fld": "fortytwo"})).unwrap(),
    ///     ],
    /// );
    /// assert_eq!(
    ///     form.fld.iter_error().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         "fortytwo",
    ///         "invalid digit found in string",
    ///     ],
    /// );
    /// let error = model_error!(
    ///     CannotSave,
    ///     "SomeModel": "breaks-business-rules",
    ///     "fld_alias": ["required"],
    /// );
    /// form.add_error(&error, &[("fld_alias", "fld")]);
    /// assert_eq!(to_value(form.fld.get_mult()).unwrap(), json!([17]));
    /// assert_eq!(
    ///     form.iter_error().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         &serde_json::to_string(&json!({"fld": "fortytwo"})).unwrap(),
    ///         "error--Model-CannotSave--SomeModel--breaks-business-rules",
    ///     ],
    /// );
    /// assert_eq!(
    ///     form.fld.iter_error().collect::<Vec<_>>(),
    ///     vec![
    ///         "update",
    ///         "fortytwo",
    ///         "invalid digit found in string",
    ///         "error--Model-CannotSave--SomeModel--fld_alias--required",
    ///     ],
    /// );
    /// ```
    fn add_error(&mut self, error: &Error, translate: &[(&str, &str)]);

    /// Add a form error. See [`to_json()`](#tymethod.to_json). Field errors
    /// should be added by [`HtmlInput`](struct.HtmlInput.html) methods.
    ///
    fn add_error_text(&mut self, error: &str);

    /// Clear the errors in the form generated by [`update()`](#method.update)
    /// or set by [`add_error()`](#method.add_error), [`add_error_text()`
    /// ](#method.add_error_text), or [`prepend_error()`
    /// ](#method.prepend_error) as well as those in all [`HtmlInput`
    /// ](struct.HtmlInput.html) fields. See [`to_json()`](#tymethod.to_json).
    ///
    fn clear_errors(&mut self);

    /// Iterate over the errors generated by [`update()`](#method.update) or
    /// set by [`add_error()`](#method.add_error), [`add_error_text()`
    /// ](#method.add_error_text), or [`prepend_error()`
    /// ](#method.prepend_error) as well as those in all [`HtmlInput`
    /// ](struct.HtmlInput.html) fields.
    ///
    fn iter_error(&self) -> std::slice::Iter<'_, String>;

    /// `true` iff errors have been generated by [`update()`](#method.update)
    /// or set by [`add_error()`](#method.add_error), [`add_error_text()`
    /// ](#method.add_error_text), or [`prepend_error()`
    /// ](#method.prepend_error) as well as those in all [`HtmlInput`
    /// ](struct.HtmlInput.html) fields.
    ///
    fn has_errors(&self) -> bool;

    /// True iff all [`HtmlInput::get()`](struct.HtmlInput.html#method.get)
    /// return `None`.
    ///
    fn is_empty(&self) -> bool;

    /// Load form with errors from session or initialize.
    ///
    /// If the form is in the session and [`has error()`s
    /// ](#tymethod.has_errors): Return the form as found, but store a version
    /// without errors in the session first.
    ///
    /// If not: Return a form initialized using `init` and store it in the
    /// session.
    ///
    fn load_errors_or_else<I>(srv: HttpServerIf, init: I) -> Self
    where
        Self: SessionModel,
        I: FnOnce() -> Self,
    {
        match srv.session_get::<Self>(Self::key()) {
            Some(loaded) if loaded.has_errors() => {
                let mut stored = loaded.clone();
                stored.clear_errors();
                let _ = stored.store(srv);
                loaded
            }
            _ => {
                let initialized = init();
                let _ = initialized.store(srv);
                initialized
            }
        }
    }

    /// Prepend an error to the list of errors.
    ///
    fn prepend_error(&mut self, error: &str);

    /*
    /// Output an HTML form, unescaped. This will be a basic form, with no
    /// control over the generated HTML except that implied by the field
    /// attributes, see the [examples](#examples).
    ///
    /// If, as is often the case, you need more finetuning of the HTML, use
    /// [`to_json()`](#tymethod.to_json).
    ///
    fn to_form(&self) -> String;
    */

    /// Output a JSON object suitable for sending to the [template engine
    /// ](../../http/server/struct.TemplEngIf.html#method.render).
    ///
    /// See the [examples](#examples) for details.
    ///
    fn to_json(&self) -> JsonValue;

    /// Store the form in the [session
    /// ](../../session_model/trait.SessionModel.html#method.store) and, if
    /// successful, [`to_json()`](#tymethod.to_json).
    ///
    fn to_json_session(&self, srv: HttpServerIf) -> Result<JsonValue, Error>
    where
        Self: SessionModel,
    {
        self.store(srv).map(|_| self.to_json())
    }

    /// Output a JSON object containing all the `HtmlInput` field values
    /// `{"<field name>": <self.get_mult() as JSON Array>, ... }`.
    ///
    fn to_json_values(&self) -> JsonValue;

    /// Update all [`HtmlInput`](struct.HtmlInput.html) fields in `self` from
    /// `json`, which should be a JSON object with keys corresponding to the
    /// fields in `Self`.
    ///
    /// A field with no corresponding entry in `json` is not updated.
    ///
    /// A key that does not correspond to any field is ignored.
    ///
    /// If something goes wrong no field values are updated, the field
    /// specific error messages are stored in the `HtmlInput` fields, general
    /// error messages are stored by [`add_error()`](#tymethod.add_error), and
    /// an error message `"update"` is [prepended](#tymethod.prepend_error) to
    /// the general ones. The returned error is an [`invalid_input("update")`
    /// ](../../error/enum.Error.html#variant.InvalidInput).
    ///
    /// <b>Tip:</b> `update()`, though intended primarily to be called with
    /// data received by the [HTTP server
    /// ](../../http/server/struct.HttpServerIf.html#method.param_json), may
    /// also be used before calling `to_json()`, to set many of the
    /// `HtmlInput` field values at once by using the [`serde_json::json`
    /// ](../../../serde_json/macro.json.html) macro to set the parameter
    /// `json`. See the [examples](#examples).
    ///
    fn update(&mut self, json: &JsonValue) -> Result<(), Error>;

    /// Create and update the object:
    ///
    /// A form is [loaded or initialized by `init()`
    /// ](../../session_model/trait.SessionModel.html#method.load_or_else) and
    /// [forgotten
    /// ](../../session_model/trait.SessionModel.html#method.forget).
    ///
    /// The fields are updated from `json` by [`update()`](#tymethod.update).
    ///
    /// The created and possibly partially updated object is returned also on
    /// error, since the state loaded from the web session and error messages
    /// from the `HtmlInput` fields are stored there.
    ///
    fn update_session<I>(
        srv: HttpServerIf,
        json: &JsonValue,
        init: I,
    ) -> Result<Self, Self>
    where
        Self: SessionModel,
        I: FnOnce() -> Self,
    {
        let mut obj = Self::load_or_else(srv, init);
        Self::forget(srv);
        obj.clear_errors();
        match obj.update(json) {
            Ok(_) => Ok(obj),
            Err(_) => Err(obj),
        }
    }
}

/// the keys are all optional but must be in alphabetical order!
#[cfg(debug_assertions)]
#[macro_export]
macro_rules! assert_html_form {
    (
        $form:expr,
    $(  form_errors: [ $( $form_error:expr ),* ], )?
    $(
        inputs: {
        $(
            $input:ident: {
            $(
                attrs: {
                $(
                    $attr_w_val:literal: [ $( $attr:expr ),* $( , )? ]
                ),*
                    $( , )?
                },
            )?
            $(  attrs_wo_val: [ $( $attr_wo_val:literal ),* $( , )? ], )?
            $(  errors: [ $( $err:expr ),* $( , )? ], )?
            $(  tag_name: $tag_name:expr, )?
            $(  vals: [ $( $val:expr ),* $( , )? ], )?
            $(  void: $void:expr, )?
            }
        )*
        },
    )?
    ) => {
        {
            let form = $form;
            $($( // form_errors
                assert!(form.errors.contains(&$form_error.to_string()));
            )*)?
            $($( // inputs
                {
                    let input = &form.$input;
                    let tag = input.get_tag();
                $($( // attrs
                    assert!(
                        tag.get_attrs()
                            .find(|a| a.name() == $attr_w_val)
                            .is_some(),
                    );
                    assert!(
                        tag.get_attrs()
                            .find(|a| a.name() == $attr_w_val)
                            .unwrap()
                            .values()
                            .is_some(),
                    );
                $(  assert!(
                        tag.get_attrs()
                            .find(|a| a.name() == $attr_w_val)
                            .unwrap()
                            .values()
                            .unwrap()
                            .split_whitespace()
                            .find(|v| *v == $attr)
                            .is_some(),
                        );
                )*
                )*)?
                $($( // attrs_wo_val
                    assert!(
                        tag.get_attrs()
                            .find(|a| a.name() == $attr_wo_val)
                            .is_some(),
                    );
                    assert!(
                        tag.get_attrs()
                            .find(|a| a.name() == $attr_wo_val)
                            .unwrap()
                            .values()
                            .is_none(),
                    );
                )*)?
                $($( // errors
                    assert!(
                        input
                            .iter_error()
                            .find(|e| e == &&$err.to_string())
                            .is_some(),
                    );
                )*)?
                $( // tag_name
                    assert!(tag.tag_name() == $tag_name);
                )?
                $($( // vals
                    assert!(
                        input
                            .iter()
                            .find(|e| e == &&$val)
                            .is_some(),
                    );
                )*)?
                $( // void
                    assert!(tag.void() == $void);
                )?
                }
            )*)?
        }
    };
}
