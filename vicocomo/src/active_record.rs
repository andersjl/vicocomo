//! Traits implemented by model objects persisted in an SQL database, and some
//! helper types for querying the objects in the database.
//!
//! The trait [`ActiveRecord`](trait.ActiveRecord.html) has a [derive macro
//! ](../../vicocomo_active_record/derive.ActiveRecord.html) with the same name.

use crate::error::{ModelError, ModelErrorKind};
use crate::{map_error, t, DatabaseIf, DbType, DbValue, Error};
use ljumvall_utils::first_n_chars_ellipsis;
use regex::Regex;
use std::cmp::min;
use std::str::from_utf8;

/// The (major, minor) Vicocomo version where the current backup format was
/// first used, see [`define_backup_and_restore!()`
/// ](../macro.define_backup_and_restore.html).
///
pub const BACKUP_VERSION: (u32, u32) = (0, 6);

// === ActiveRecord ==========================================================

/// Help to implement the well-known Acitve Record pattern (see Martin Fowler:
/// [Patterns of Enterprise Application Architecture
/// ](https://martinfowler.com/eaaCatalog/activeRecord.html).
///
/// There is a [derive macro
/// ](../../vicocomo_active_record/derive.ActiveRecord.html). The trait should
/// be used as an interface to a *thin* wrapping of the database! Avoid coding
/// elaborate business rules etc in methods of the deriving `struct`. Use
/// [contexts](https://en.wikipedia.org/wiki/Data,_context_and_interaction)
/// for that. *Especially* if the logic involves more than one `ActiveRecord`
/// class, or classes with no direct relation to the database.
///
/// Note that the derive macro implements a number of functions that are *not*
/// in the trait! These are mainly functions for either side of one-to-many or
/// many-to-many associations between this type and another (or the same)
/// type.
//
// It proved tedious and with no obvious gain execpt possibly machine code
// size to avoid this function name generation using generics.
///
/// For those non-trait functions, see the [derive macro `ActiveRecord`
/// ](../derive.ActiveRecord.html).
///
pub trait ActiveRecord: Sized {
    /// <b>No primary key</b>: `()`. Some functions are useful also for
    /// relations that have no primary key, e.g. views.
    ///
    /// <b>Exactly one primary key</b>: The type of the primary key field or
    /// the held type if it is an `Option` (see the derive macro attributes
    /// [`vicocomo_optional`](../derive.ActiveRecord.html#vicocomo_optional)
    /// and [`vicocomo_random`](../derive.ActiveRecord.html#vicocomo_random)).
    ///
    /// <b>More than one primary key</b>: A tuple of the types of the primary
    /// keys, again with `Option` stripped.
    ///
    type PkType;

    //- Common functions ---------------------------------------------------//

    //- Required - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// A clone of the value of the primary key(s) (see [`PkType`
    /// ](#associatedtype.PkType)) or `None` if any of them is `None` or
    /// `PkType` is `()`.
    // TODO: should it return Some(()) if PkType is ()?
    ///
    fn pk_value(&self) -> Option<Self::PkType>;

    //- Functions for deleting models from the database --------------------//

    //- Required - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Returns `Ok(())` iff the corresponding database row is deleted.
    ///
    /// The implementation should ensure referential integrity, e.g. relying
    /// on the database's referential integrity.
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::Model)`](../error/enum.Error.html#variant.Model)
    /// if
    /// - self has no primary key, or
    /// - the model implements [`BeforeDelete`](trait.BeforeDelete.html) and
    ///   `before_delete()` returns an error.
    ///
    /// The method generated by the derive macro always returns
    /// [`Err(Error::Other("not-available")`
    /// ](../error/enum.Error.html#variant.Other) if the model has the
    /// attribute [`vicocomo_readonly`
    /// ](../derive.ActiveRecord.html#vicocomo_readonly).
    ///
    /// For referential integrity and other error handling, see
    /// [`delete_batch()`](#tymethod.delete_batch).
    ///
    fn delete(self, db: DatabaseIf) -> Result<(), Error>;

    /// Returns `Ok(batch.len())` iff each key in `batch` identifies a database
    /// row that is deleted.
    ///
    /// `batch` should be a slice of primary key values, see [`PkType`
    /// ](#associatedtype.PkType).
    ///
    /// The implementation should not call [`before_delete()`
    /// ](trait.BeforeDelete.html#tymethod.before_delete). You have to use
    /// [`delete()`](#tymethod.delete) for that.
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::Model)`](../error/enum.Error.html#variant.Model)
    /// for the first of the objects referred to in `batch` that
    /// - does not exist in the database, or
    /// - cannot be deleted because of a database foreign key constraint, or
    /// - cannot be deleted for application specific reasons.
    ///
    /// The method generated by the derive macro always returns
    /// [`Err(Error::Other("not-available")`
    /// ](../error/enum.Error.html#variant.Other) if `PkType` is `()` or the
    /// model has the attribute [`vicocomo_readonly`
    /// ](../derive.ActiveRecord.html#vicocomo_readonly).
    ///
    /// Forward other database errors as [`Error::Database`
    /// ](../error/enum.Error.html#variant.Database).
    ///
    fn delete_batch(
        db: DatabaseIf,
        batch: &[Self::PkType],
    ) -> Result<usize, Error>;

    //- Functions for retrieving models from the database ------------------//

    //- Required - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Find an object in the database by primary key(s).
    ///
    /// `db` is the database connection object.
    ///
    /// `pk` is the primary key value(s), see [`PkType`
    /// ](#associatedtype.PkType).
    ///
    /// Returns `None` if `PkType` is `()`.
    ///
    fn find(db: DatabaseIf, pk: &Self::PkType) -> Option<Self>;

    /// Find this object in the database by primary key.
    ///
    /// `db` is the database connection object.
    ///
    /// Returns `None` if `PkType` is `()`.
    ///
    fn find_equal(&self, db: DatabaseIf) -> Option<Self>;

    /// Returns a vector with all records in the table in the default order.
    ///
    /// `db` is the database connection object.
    ///
    /// <b>Errors</b>
    ///
    /// Forwards database errors as [`Error::Database`
    /// ](../error/enum.Error.html#variant.Database).
    ///
    fn load(db: DatabaseIf) -> Result<Vec<Self>, Error>;

    /// Returns a vector with a possibly limited number of records that satisfy
    /// a condition possibly in a specified order.
    ///
    /// `query` is a [`Query`](struct.Query.html), see that and
    /// [`QueryBld`](struct.QueryBld.html).
    ///
    /// <b>Errors</b>
    ///
    /// Forwards database errors as [`Error::Database`
    /// ](../error/enum.Error.html#variant.Database).
    ///
    fn query(db: DatabaseIf, query: &Query) -> Result<Vec<Self>, Error>;

    //- Provided - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Returns `true` iff there are no data in the datbase for this model.
    ///
    fn is_empty(db: DatabaseIf) -> Result<bool, Error> {
        Self::query(
            db,
            &QueryBld::new()
                .limit(1)
                .query()
                .ok_or_else(|| Error::this_cannot_happen(""))?,
        )
        .map(|v| v.len() == 0)
    }

    /// Returns an [`Error::Model`](../error/enum.Error.html#variant.Model) if
    /// there is no object in the database whith the given primary key(s). See
    /// [`find()`](#tymethod.find).
    ///
    /// The default implementaion uses `find()` in the obvious way. If
    /// `PkType` is `()` this means that it always returns `Err(_)`.
    ///
    fn validate_exists(
        db: DatabaseIf,
        pk: &Self::PkType,
        msg: &str,
    ) -> Result<(), Error> {
        match Self::find(db, pk) {
            Some(_) => Ok(()),
            None => Err(Error::Model(ModelError {
                error: ModelErrorKind::NotFound,
                model: "Self".to_string(),
                general: Some(msg.to_string()),
                field_errors: Vec::new(),
                assoc_errors: Vec::new(),
            })),
        }
    }

    /// Returns an [`Error::Model`](../error/enum.Error.html#variant.Model) if
    /// this object is already stored in the database. See [`find_equal()`
    /// ](#tymethod.find_equal).
    ///
    /// The default implementaion uses `find_equal()` in the obvious way. If
    /// `PkType` is `()` this means that it always returns `Ok(())`.
    ///
    fn validate_unique(
        &self,
        db: DatabaseIf,
        msg: &str,
    ) -> Result<(), Error> {
        match self.find_equal(db) {
            Some(_) => Err(Error::Model(ModelError {
                error: ModelErrorKind::NotUnique,
                model: "Self".to_string(),
                general: Some(msg.to_string()),
                field_errors: Vec::new(),
                assoc_errors: Vec::new(),
            })),
            None => Ok(()),
        }
    }

    //- Functions for saving new or old objects to the database ------------//

    //- Required - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Try to INSERT a number of rows in the database from `data` and return
    /// new model structs updated from the inserted rows after insert.
    ///
    /// Note that the implementation by the derive macro ensures that any
    /// field with the attribute
    /// [`vicocomo_optional`](../derive.ActiveRecord.html#vicocomo_optional)
    /// or [`vicocomo_random`](../derive.ActiveRecord.html#vicocomo_random)
    /// will be sent to the database only if it is `Some`.
    ///
    /// Ensures that either none (on `Err(_)` return) or all of the models in
    /// `data` are inserted.
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::Model)`](../error/enum.Error.html#variant.Model)
    /// for the first of the objects in `data` that
    /// - has a given primary key that is invalid or already present in the
    ///   database, or
    /// - has an invalid remote reference (e.g. relying on the database's
    ///   referential integrity), or
    /// - uses [`before_save()`](trait.BeforeSave.html#tymethod.before_save)
    ///   which returns an error, or
    /// - for application specific reasons.
    ///
    /// The method generated by the derive macro always returns
    /// [`Err(Error::Other("not-available")`
    /// ](../error/enum.Error.html#variant.Other) if the model has the
    /// attribute [`vicocomo_readonly`
    /// ](../derive.ActiveRecord.html#vicocomo_readonly)
    ///
    /// Forward other database errors as [`Error::Database`
    /// ](../error/enum.Error.html#variant.Database).
    ///
    fn insert_batch(
        db: DatabaseIf,
        data: &mut [Self],
    ) -> Result<Vec<Self>, Error>;

    /// Try to UPDATE a row in the database from `self` and update self from
    /// the updated row after update.
    ///
    /// Note that the implementation by the derive macro ensures that any
    /// field with the attribute
    /// [`vicocomo_optional`](../derive.ActiveRecord.html#vicocomo_optional)
    /// or [`vicocomo_random`](../derive.ActiveRecord.html#vicocomo_random)
    /// will be sent to the database only if it is `Some`.
    ///
    /// The implementation should ensure referential integrity, see
    /// [`insert_batch()`](#tymethod.insert_batch).
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::Model)`](../error/enum.Error.html#variant.Model)
    /// if `self`
    /// - does not have a primary key that exists in the database, or
    /// - has an invalid remote reference (e.g. relying on the database's
    ///   referential integrity), or
    /// - uses [`before_save()`](trait.BeforeSave.html#tymethod.before_save)
    ///   which returns an error, or
    /// - for application specific reasons.
    ///
    /// The method generated by the derive macro always returns
    /// [`Err(Error::Other("not-available")`
    /// ](../error/enum.Error.html#variant.Other) if `PkType` is `()` or the
    /// model has the attribute [`vicocomo_readonly`
    /// ](../derive.ActiveRecord.html#vicocomo_readonly).
    ///
    /// Returns [`Err(Error::Database)`
    /// ](../error/enum.Error.html#variant.Database) if the database update
    /// fails for some other reason.
    ///
    fn update(&mut self, db: DatabaseIf) -> Result<(), Error>;

    /// Try to UPDATE the row in the database corresponding to `self`.  Each
    /// pair in `cols` is the name of a database column and the new value.
    ///
    /// On successful return `self` is updated from the database.  On error,
    /// `self` is unchanged.
    ///
    /// <b>Note</b> that this function updates directly to the database and
    /// should
    /// - not call [`before_save()`
    ///   ](trait.BeforeSave.html#tymethod.before_save),
    /// - ignore the visibility of the fields in `self` corresponding to the
    ///   `cols`,
    /// - send data to the database ignoring
    ///   [`vicocomo_optional`](../derive.ActiveRecord.html#vicocomo_optional)
    ///   and [`vicocomo_random`](../derive.ActiveRecord.html#vicocomo_random)
    ///   attributes, and
    /// - forward database errors without conversion.
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::Model)`](../error/enum.Error.html#variant.Model)
    /// if `self` does not have a primary key.
    ///
    /// The method generated by the derive macro always returns
    /// [`Err(Error::Other("not-available")`
    /// ](../error/enum.Error.html#variant.Other) if `PkType` is `()` or the
    /// model has the attribute [`vicocomo_readonly`
    /// ](../derive.ActiveRecord.html#vicocomo_readonly).
    ///
    /// Returns [`Err(Error::Database)`
    /// ](../error/enum.Error.html#variant.Database) if the database update
    /// fails for some other reason.
    ///
    fn update_columns(
        &mut self,
        db: DatabaseIf,
        cols: &[(&str, DbValue)],
    ) -> Result<(), Error>;

    //- Provided - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Try to INSERT a row in the database from `self` and update `self` from
    /// the inserted row after insert.
    ///
    /// The default implementation calls [`insert_batch()`
    /// ](#tymethod.insert_batch).
    ///
    /// <b>Errors</b>
    ///
    /// See [`insert_batch()`](#tymethod.insert_batch).
    ///
    fn insert(&mut self, db: DatabaseIf) -> Result<(), Error> {
        *self = Self::insert_batch(db, std::slice::from_mut(self))?
            .pop()
            .unwrap();
        Ok(())
    }

    /// Save the object's data to the database.
    ///
    /// If a row with an object's primary key exists in the database, this
    /// should be equivalent to [`update()`](#tymethod.update).
    /// If not, this should be equivalent to [`insert()`](#method.insert).
    ///
    /// The default implementation uses the [`pk_value()`](#tymethod.pk_value)
    /// and [`find()`](#tymethod.find) methods to decide whether to `update()`
    /// or `insert()`.
    ///
    /// <b>Errors</b>
    ///
    /// See [`update()`](#tymethod.update) and [`insert()`](#method.insert).
    ///
    fn save(&mut self, db: DatabaseIf) -> Result<(), Error> {
        match self.pk_value() {
            Some(pk) if Self::find(db.clone(), &pk).is_some() => {
                self.update(db.clone())
            }
            _ => self.insert(db.clone()),
        }
    }

    //- Functions for backup and restore -----------------------------------//

    //- Required - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Returns the [database type](../database/enum.DbType.html) of `col` if
    /// it is the name of a database column used for storing the model.
    ///
    fn col_type(col: &str) -> Option<DbType>;

    /// Returns the column names.
    ///
    fn columns() -> Vec<String>;

    /// True iff the model is readonly, e.g. representing a database view.
    ///
    fn readonly() -> bool;

    /// Returns the name of the database table.
    ///
    fn table() -> String;

    /// Returns the values of the model object in the order of [`columns()`
    /// ](#tymethod.columns).
    ///
    /// <b> Errors </b>
    ///
    /// Returns [`Error::Model`
    /// ](../error/struct.ModelError.html#variant.Model) if a field is
    /// [`vicocomo_optional`](../derive.ActiveRecord.html#vicocomo_optional)
    /// or [`vicocomo_random`](../derive.ActiveRecord.html#vicocomo_random)
    /// and `None`.
    ///
    /// Forwards any error from the database as an [`Error::Database`
    /// ](../error/enum.Error.html#variant.Database).
    ///
    fn values(&self) -> Result<Vec<DbValue>, Error>;

    //- Provided - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

    /// Try to convert the contents of a CSV file to an SQL `INSERT` statement
    /// (e.g. to use as input to [`try_from_sql()`](#method.try_from_sql)).
    ///
    /// If `csv` contains at most one line and that line is only whitespace,
    /// an empty string is returned. Otherwise:
    ///
    /// `csv` is the contents of the CSV file. The file shall follow RFC 4180
    /// as well as the following extra requirements:
    /// - `LF` or `CRLF` line breaks are accepted.
    /// - The separator is by default `b','` but may be any ASCII character
    ///   except `"`, `CR`, `LF`, digits, `+`, `-`, `.`, `E`, `e`, and
    ///   characters that appear in the column names.
    /// - A leading header line with names of columns in [`Self::table()`
    ///   ](#tymethod.table) is <b>required</b>.
    /// - Only string and numeric values are accepted.
    /// - An empty value is converted to `NULL`, so `,"",` -> `''` but `,,` ->
    ///   `NULL`.
    /// - There is no check that the statement is valid SQL.
    /// - The first line must not be empty. Any subsequent empty line is
    ///   interpreted as `(NULL)`.
    /// - Values of string columns in `csv` are accepted even if not quoted.
    /// - Values of numeric columns in `csv` are accepted even if quoted.
    ///
    /// Apart from the obvious `""` -> `"` and `'` -> `''` the bytes in string
    /// values are preserved.
    ///
    /// Returns an SQL statement in the form
    /// `"INSERT INTO table (col, ...) VALUES (val, ...), ...;"`.
    ///
    /// <b>Unless</b> there are no value rows in the CSV, in which case an
    /// empty string is returned.
    ///
    /// <b> Errors </b>
    ///
    /// Returns `Err(Error::`[`InvalidInput`
    /// ](../error/enum.Error.html#variant.InvalidInput)`)` if the conversion
    /// fails.
    ///
    fn try_csv_to_sql(csv: &str, sep: Option<u8>) -> Result<String, Error> {
        fn get_line<'csv>(
            csv: &'csv str,
            sep: &str,
        ) -> Result<(Vec<Option<&'csv str>>, &'csv str), Error> {
            use logos::Logos;

            #[derive(Logos, Debug, PartialEq)]
            enum Tok {
                #[regex(r"\r?\n")]
                Lin,

                #[regex(r"[^\r\n]")]
                Chr,

                #[regex(r#""(?:[^"]|"")*""#)]
                Qte,

                // End is not a token, it denotes lex.next().is_none()
            }

            #[rustfmt::skip]
            #[derive(Clone, Copy, Debug, PartialEq)]
            enum State {
                Expect,   // Lin|End   => None,  return
                          // Chr sep   => None,  Expect
                          // Chr !sep  =>        Reading
                          // Qte       => Some,  GotQte
                Reading,  // Lin|End   => Some,  return
                          // Chr sep   => Some,  Expect
                          // Chr !sep  =>        Reading
                GotQte,   // Lin|End   =>        return
                          // Chr sep   =>        Expect
            }

            let mut line = Vec::new();
            let mut lex = Tok::lexer(csv);
            let mut state = State::Expect;
            let mut first = 0usize;
            loop {
                match lex.next() {
                    Some(tok) => match tok {
                        Ok(tok) => match state {
                            State::Expect => match tok {
                                Tok::Lin => {
                                    line.push(None);
                                    return Ok((line, lex.remainder()));
                                }
                                Tok::Chr if lex.slice() == sep => {
                                    line.push(None);
                                    state = State::Expect;
                                }
                                Tok::Chr => {
                                    first = lex.span().start;
                                    state = State::Reading;
                                }
                                Tok::Qte => {
                                    line.push(Some(
                                        &lex.slice()
                                            [1..(lex.slice().len() - 1)],
                                    ));
                                    state = State::GotQte;
                                }
                            },
                            State::Reading => match tok {
                                Tok::Lin => {
                                    line.push(Some(
                                        &csv[first..(lex.span().start)],
                                    ));
                                    return Ok((line, lex.remainder()));
                                }
                                Tok::Chr if lex.slice() == sep => {
                                    line.push(Some(
                                        &csv[first..(lex.span().start)],
                                    ));
                                    state = State::Expect;
                                }
                                Tok::Chr => (),
                                _ => break,
                            },
                            State::GotQte => match tok {
                                Tok::Lin => {
                                    return Ok((line, lex.remainder()));
                                }
                                Tok::Chr if lex.slice() == sep => {
                                    state = State::Expect;
                                }
                                _ => break,
                            },
                        },
                        _ => break,
                    },
                    _ => {
                        match state {
                            State::Expect => line.push(None),
                            State::Reading => {
                                line.push(Some(
                                    &csv[first..(lex.span().start)],
                                ));
                            }
                            State::GotQte => (),
                        }
                        return Ok((line, ""));
                    }
                }
            }
            Err(Error::invalid_input(format!(
                "{}:  {:?}",
                t!("invalid-csv"),
                first_n_chars_ellipsis(lex.remainder(), 40, " ..."),
            )))
        }

        // "" => ", ' => ''
        fn requote(txt: &str) -> String {
            txt.replace("\"\"", "\"").replace("'", "''")
        }

        if csv.trim().is_empty() {
            return Ok(String::new());
        }
        let sep = [sep.unwrap_or(b',')];
        let sep = from_utf8(&sep).map_err(|e| {
            Error::invalid_input(&format!(
                "{}: {sep:?}, {e}",
                t!("invalid-csv-separator"),
            ))
        })?;
        let mut sql = format!("INSERT INTO {} (", Self::table());
        let mut is_text = Vec::new();
        let mut col_ix = 0usize;
        let mut rest = csv;
        let (line, more) = get_line(rest, sep)?;
        rest = more;
        {
            for nam in line {
                if nam.is_none() {
                    return Err(Error::invalid_input("invalid-csv-header"));
                }
                let nam = nam.unwrap();
                is_text.push(match Self::col_type(nam) {
                    Some(t) => t == DbType::Text || t == DbType::NulText,
                    None => {
                        return Err(Error::invalid_input(
                            "invalid-csv-header",
                        ));
                    }
                });
                if col_ix > 0 {
                    sql += ", ";
                }
                sql += nam;
                col_ix += 1;
            }
            sql += ")";
        }
        let mut got_vals = false;
        while !rest.is_empty() {
            if got_vals {
                sql += ", (";
            } else {
                sql += " VALUES (";
                got_vals = true;
            }
            let (line, more) = get_line(rest, sep)?;
            rest = more;
            col_ix = 0;
            for val in &line {
                if col_ix > 0 {
                    sql += ", ";
                }
                match is_text.get(col_ix) {
                    Some(quote_needed) => match val {
                        Some(v) => {
                            if *quote_needed {
                                sql = sql + "'" + &requote(v) + "'";
                            } else {
                                sql += v;
                            }
                        }
                        None => sql += "NULL",
                    },
                    None => {
                        return Err(Error::invalid_input(format!(
                            "{}: {:?}",
                            t!("invalid-csv"),
                            line,
                        )))
                    }
                }
                col_ix += 1;
            }
            sql += ")";
        }
        Ok(if got_vals { sql + ";" } else { String::new() })
    }

    /// Try to load data to the table corresponding to `Self` from a
    /// CSV-formatted string.
    ///
    /// This is basically
    /// [`try_from_sql`](#method.try_from_sql)`(db, `[`try_csv_to_sql`](#method.try_csv_to_sql)`(csv, sep)`.
    /// See those, but the requirements on `csv` differs somehwat:
    /// - `csv` <b>shall</b> start with a header line with the names of at
    ///   least the columns corresponding to [non-optional
    ///   ](../derive.ActiveRecord.html#vicocomo_optional) fields.
    /// - If an [optional](../derive.ActiveRecord.html#vicocomo_optional)
    ///   column is present, and the field is also [required
    ///   ](../derive.ActiveRecord.html#vicocomo_required) its value *cannot
    ///   be `NULL`*.
    ///   <br><small>This can actually happen if the column is delcared
    ///   `NOT NULL DEFAULT ...` in the database.</small>
    ///
    fn try_from_csv(
        db: DatabaseIf,
        csv: &str,
        sep: Option<u8>,
    ) -> Result<(), Error> {
        Self::try_from_sql(db.clone(), &Self::try_csv_to_sql(csv, sep)?)
    }

    /// Try to load data to the table corresponding to `Self` from a string as
    /// returned by [`try_to_sql()`](#method.try_to_sql).
    ///
    /// If `sql` contains no SQL statements, no error and the table is left
    /// empty.
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::Other("not-available"))`
    /// ](../error/enum.Error.html#variant.Other) if the model has the
    /// attribute [`vicocomo_readonly`
    /// ](../derive.ActiveRecord.html#vicocomo_readonly).
    ///
    /// Returns [`Err(Error::InvalidInput)`
    /// ](../error/enum.Error.html#variant.InvalidInput) if `sql` is not only
    /// whitespace and does not begin with `INSERT INTO `*the model's table
    /// name*.
    ///
    /// Returns [`Err(Error::Database)`
    /// ](../error/enum.Error.html#variant.Database) if the database update
    /// fails for some other reason.
    ///
    fn try_from_sql(db: DatabaseIf, sql: &str) -> Result<(), Error> {
        fn do_it(db: DatabaseIf, sql: &str, tbl: &str) -> Result<(), Error> {
            if !sql.trim().is_empty() {
                if !map_error!(
                    InvalidInput,
                    Regex::new(
                        &format!(r"^\s*(?i:INSERT\s+INTO)\s+{}", tbl,)
                    )
                )?
                .is_match(sql)
                {
                    return Err(Error::invalid_input(format!(
                        "{}: {}",
                        t!("invalid-insert-sql"),
                        first_n_chars_ellipsis(sql, 40, " ..."),
                    )));
                }
            }
            let del = format!("DELETE FROM {tbl}");
            #[cfg(debug_assertions)]
            eprintln!("{del}");
            db.clone().exec(&del, &[])?;
            if !sql.trim().is_empty() {
                #[cfg(debug_assertions)]
                eprintln!("{}", first_n_chars_ellipsis(sql, 40, " ..."));
                db.clone().exec(sql, &[])?;
            }
            Ok(())
        }

        if Self::readonly() {
            return Err(Error::other("not-available"));
        }
        do_it(db, sql, &Self::table()).map_err(|e| {
            Error::invalid_input(&format!(
                "{}: {}\n{}:\n{}",
                t!("database-error"),
                e,
                t!("incompatible-sql"),
                first_n_chars_ellipsis(sql, 100, " ..."),
            ))
        })
    }

    /// Try to convert an SQL `INSERT` statement (e.g. as returned by
    /// [`try_to_sql()`](#method.try_to_sql)) to CSV.
    ///
    /// This method does not use any other trait method, and is not expected
    /// to be overridden.
    ///
    /// If `sql` contains only whitespace, returns a pair
    /// `(`*table name*`, "\r\n")`. Otherwise:
    ///
    /// `sql` should be one SQL `INSERT INTO {Self::table_name()} ...`
    /// statement, optionally semicolon terminated, subject to the following
    /// conditions:
    /// - <b>No parameterization, only literal values</b>
    /// - <b>Only numeric and string literals</b>
    ///
    /// `sep` is the separator to use in the CSV string. Default `b','`.
    ///
    /// If `headers` the first line in the CSV string is the table column
    /// names.
    ///
    /// Returns a pair `(`*table name*`, `*CSV with `CRLF` line endings*`)`.
    ///
    /// Apart from the obvious `"` -> `""` and `''` -> `'` the bytes in string
    /// values are not interpreted.
    ///
    /// <b>Errors</b>
    ///
    /// Returns [`Err(Error::InvalidInput)`
    /// ](../error/enum.Error.html#variant.InvalidInput) if `sql` is not of
    /// the form `"INSERT INTO table (col, ...) VALUES (val, ...), ..."`.
    ///
    fn try_sql_to_csv(
        sql: &str,
        sep: Option<u8>,
        headers: bool,
    ) -> Result<(String, String), Error> {
        // TODO better error messages using logos::Span

        use logos::Logos;

        #[derive(Logos, Debug, PartialEq)]
        #[logos(skip r"[ \t\n\f]+")]
        enum Tok {
            #[regex(r"[iI][nN][sS][eE][rR][tT]\s+[iI][nN][tT][oO]")]
            Ini,

            #[token("(")]
            Lpr,

            #[regex(r"[A-Za-z]\w*")]
            Nam,

            #[token(",")]
            Com,

            #[token(")")]
            Rpr,

            #[regex(r"[vV][aA][lL][uU][eE][sS]")]
            Val,

            #[regex(
                r"-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?",
                priority = 2
            )]
            Num,

            #[regex(
                r"'[^']*(?:''[^']*)*'",
                |lex| requote(&lex.slice()[1..(lex.slice().len() - 1)]),
            )]
            Txt(String),

            #[regex(r"[nN][uU][lL][lL]")]
            Nul,

            #[token(";")]
            Sem,
            // End is not a token, it denotes lexer.next().is_none()
        }

        #[rustfmt::skip]
        #[derive(Clone, Copy, Debug, PartialEq)]
        enum State {
            ExpectInLit,   // Ini       => ExpectTable
            ExpectTable,   // Nam       => "{val}" -> table  ExpectNames
            ExpectNames,   // Lpr       => ""                ExpectName
            ExpectName,    // Nam       => "{val}"           GotName
            GotName,       // Com       => "{sep}"           ExpectName
                           // Rpr       => "{CRLF}"          ExpectValLit
            ExpectValLit,  // Val       => ""                ExpectVals
            ExpectVals,    // Lpr       => ""                ExpectVal
            ExpectVal,     // Num|Txt   => "{val}"           GotVal
                           // Nul       => ""                GotVal
            GotVal,        // Com       => "{sep}"           ExpectVal
                           // Rpr       => "{CRLF}"          GotVals
            GotVals,       // Com       => ""                ExpectVals
                           // Sem|End   => ""                Success
            Error,         // We end here for all unexpected tokens
            Success,       // We end here if all went well
        }

        // " -> "", '' => '
        fn requote(txt: &str) -> String {
            txt.replace("\"", "\"\"").replace("''", "'")
        }

        let sep = [sep.unwrap_or(b',')];
        let sep = from_utf8(&sep).map_err(|e| {
            Error::invalid_input(&format!(
                "{}: {sep:?}, {e}",
                t!("invalid-csv-separator"),
            ))
        })?;
        if sql.trim().is_empty() {
            return Ok((Self::table(), String::from("\r\n")));
        }
        let mut table = String::new();
        let mut csv = String::new();
        let mut lex = Tok::lexer(sql);
        let mut state = State::ExpectInLit;
        loop {
            match lex.next() {
                Some(tok) => match tok {
                    Ok(tok) => match state {
                        State::ExpectInLit => match tok {
                            Tok::Ini => state = State::ExpectTable,
                            _ => state = State::Error,
                        },
                        State::ExpectTable => match tok {
                            Tok::Nam => {
                                table = lex.slice().to_string();
                                state = State::ExpectNames;
                            }
                            _ => state = State::Error,
                        },
                        State::ExpectNames => match tok {
                            Tok::Lpr => state = State::ExpectName,
                            _ => state = State::Error,
                        },
                        State::ExpectName => match tok {
                            Tok::Nam => {
                                if headers {
                                    csv += lex.slice();
                                }
                                state = State::GotName;
                            }
                            _ => state = State::Error,
                        },
                        State::GotName => match tok {
                            Tok::Com => {
                                if headers {
                                    csv += sep;
                                }
                                state = State::ExpectName;
                            }
                            Tok::Rpr => {
                                if headers {
                                    csv += "\r\n";
                                }
                                state = State::ExpectValLit;
                            }
                            _ => state = State::Error,
                        },
                        State::ExpectValLit => match tok {
                            Tok::Val => state = State::ExpectVals,
                            _ => state = State::Error,
                        },
                        State::ExpectVals => match tok {
                            Tok::Lpr => state = State::ExpectVal,
                            _ => state = State::Error,
                        },
                        State::ExpectVal => match tok {
                            Tok::Num => {
                                csv += lex.slice();
                                state = State::GotVal;
                            }
                            Tok::Txt(val) => {
                                csv = csv + "\"" + &val + "\"";
                                state = State::GotVal;
                            }
                            Tok::Nul => state = State::GotVal,
                            _ => state = State::Error,
                        },
                        State::GotVal => match tok {
                            Tok::Com => {
                                csv += sep;
                                state = State::ExpectVal;
                            }
                            Tok::Rpr => {
                                csv += "\r\n";
                                state = State::GotVals;
                            }
                            _ => state = State::Error,
                        },
                        State::GotVals => match tok {
                            Tok::Com => state = State::ExpectVals,
                            Tok::Sem => state = State::Success,
                            _ => state = State::Error,
                        },
                        _ => state = State::Error,
                    },
                    _ => state = State::Error,
                },
                _ => match state {
                    State::GotVals => state = State::Success,
                    _ => state = State::Error,
                },
            }
            if state == State::Error || state == State::Success {
                break;
            }
        }
        if state == State::Success {
            Ok((table.to_string(), csv))
        } else {
            Err(Error::invalid_input(format!(
                "{}: {:?}",
                t!("invalid-sql-insert"),
                first_n_chars_ellipsis(lex.remainder(), 40, " ..."),
            )))
        }
    }

    /// Returns the contents of the table corresponding to `Self` in a pair
    /// `(` *table name* `,` *a string suitable for saving as a CSV file* `)`.
    ///
    /// This is simply [`try_sql_to_csv`
    /// ](#method.try_sql_to_csv)[`(try_to_sql()`
    /// ](#method.try_to_sql)`, sep, true)`.
    ///
    /// See those.
    ///
    fn try_to_csv(
        db: DatabaseIf,
        sep: Option<u8>,
    ) -> Result<(String, String), Error> {
        Self::try_sql_to_csv(&Self::try_to_sql(db)?, sep, true)
    }

    /// Returns the contents of the table corresponding to `Self` in the form
    ///
    /// `INSERT INTO `*table name*` (`*column*`, `...`) VALUES (`*value*`, `...`), `...`;`
    /// If the table is empty, an empty string is returned.
    ///
    /// <b>Errors</b>
    ///
    /// See [`values()`](#tymethod.values).
    ///
    fn try_to_sql(db: DatabaseIf) -> Result<String, Error> {
        if Self::is_empty(db.clone())? {
            return Ok(String::new());
        }
        Ok(format!(
            "INSERT INTO {} ({}) VALUES {};",
            &Self::table(),
            &Self::columns().join(", "),
            {
                let mut vals = Vec::new();
                for obj in &Self::load(db)? {
                    vals.push(format!(
                        "({})",
                        obj.values()?
                            .iter()
                            .map(|v| v.sql_value())
                            .collect::<Vec<_>>()
                            .join(", "),
                    ));
                }
                vals.join(", ")
            },
        ))
    }
}

// === BeforeDelete ==========================================================

/// A hook that may be called by the [`delete()` function
/// ](trait.ActiveRecord.html#tymethod.delete), e.g. if implemented by the
/// [`ActiveRecord` derive macro](../derive.ActiveRecord.html).
///
pub trait BeforeDelete {
    /// Do whatever necessary before deleting `self` from the database.
    ///
    /// An `Err` return value means that `self` cannot be deleted, and
    /// [`delete()`](trait.ActiveRecord.html#tymethod.delete) should return
    /// `Err` as well. `before_delete()` should *not* handle referential
    /// integrity for one-to-many associations. Those should be handled by
    /// [`delete()`](trait.ActiveRecord.html#tymethod.delete) directly.
    ///
    /// <b>Errors</b>
    ///
    /// On error return, the variant should be a [`Model`
    /// ](../error/enum.Error.html#variant.Model) indicating the offending
    /// field(s) or associations(s) and what the problem is.
    ///
    fn before_delete(&mut self, db: DatabaseIf) -> Result<(), Error>;
}

// === BeforeSave ============================================================

/// A hook called by the [`insert()`](trait.ActiveRecord.html#method.insert)
/// and [`update()`](trait.ActiveRecord.html#tymethod.update) functions as
/// implemented by the [`ActiveRecord` derive macro
/// ](../derive.ActiveRecord.html).
///
pub trait BeforeSave {
    /// Do whatever necessary before saving `self` to the database.
    ///
    /// An `Err` return value means that `self` cannot be saved, and
    /// [`insert()`](trait.ActiveRecord.html#method.insert),
    /// [`save()`](trait.ActiveRecord.html#method.save), and
    /// [`update()`](trait.ActiveRecord.html#tymethod.update) should return
    /// `Err` as well. `before_save()` should *not* handle referential
    /// integrity for many-to-one associations.  Those should be handled by
    /// [`insert()`](trait.ActiveRecord.html#method.insert), [`save()`
    /// ](trait.ActiveRecord.html#method.save), and [`update()`
    /// ](trait.ActiveRecord.html#tymethod.update) directly.
    ///
    /// <b>Errors</b>
    ///
    /// On error return, the variant should be an [`Error::Model`
    /// ](../error/enum.Error.html#variant.Model) indicating the offending
    /// field(s) or associations(s) and what the problem is.
    ///
    fn before_save(&mut self, db: DatabaseIf) -> Result<(), Error>;
}

// === macro define_backup_and_restore!() ====================================

/// Define backup and restore functions in the module where the macro is used.
///
/// `$model` are the models to back up, e.g. `crate::models::MyModel, ...`
///
/// The generated functions:
///
/// ##### `pub fn backup(db: `[`DatabaseIf`](../database/struct.DatabaseIf.html)`) -> Result<Vec<u8>, `[`Error`](../error/enum.Error.html)`>`
///
/// Returns the contents of the tables corresponding to the given `$model`s
/// using their [`try_to_csv()`](#trait.ActiveRecord.html#method.try_to_csv).
///
/// The format of the returned byte string is regarded as part of `vicocomo`s
/// public API, and begins with a line
/// `"--- vicocomo backup format version x.y ---\r\n"` where x and y are the
/// `vicocomo` major and minor version that first uses this format.
// TODO: Do not forget to change the format version in this macro when
// changing the format. This cannot be automated since the format version need
// not change with every major vicocomo version update.
///
/// Future format versions are guranteed to keep this first version line,
/// regardless of changes to the rest of the format which may be binary in
/// later versions.
///
/// <small>The application using this macro may of course have its own version
/// scheme, prepending its own version data to the output of `backup()` as
/// well as checking it before delivering the rest to `restore()`.</small>
///
/// The current version of the format after the first verion line is an utf-8
/// string containing, for each `$model`:
/// - A line `"--- `*table name*` ---\r\n"`. <b>The table name must match
///   `[0-9A-Za-z_]+`.</b>
/// - CSV data for `$model`, see [`try_from_csv()`
///   ](#trait.ActiveRecord.html#method.try_from_csv).
///
/// <b>Errors</b>
///
/// Panics if a table name contains an illegal (see above) character..
///
/// Forwards any errors from [`try_to_csv()`
/// ](#trait.ActiveRecord.html#method.try_to_csv).
///
/// ##### `pub fn restore(db: `[`DatabaseIf`](../database/struct.DatabaseIf.html)`, source: &[u8]) -> Result<(), `[`Error`](../error/enum.Error.html)`>`
///
/// Restore the data of the given `$model`s from `source` using their
/// [`try_from_csv()`](#trait.ActiveRecord.html#method.try_from_csv).
///
/// For the format of `source`, see [above
/// ](#pub-fn-backupdb-databaseif---resultstring-error).
///
/// The restoration is guarded by a transaction. The tables are deleted and
/// restored one by one. For tables that have foreign key constraints this
/// generally implies:
/// - Foreign keys should be declared `DEFERRABLE INITIALLY DEFERRED`.
/// - The declaration should <b>not</b> contain `ON DELETE RESTRICT`, since
///   this is not deferrable. `ON DELETE NO ACTION` is fine, and works just
///   like `RESTRICT` when not in a transaction.
///
/// <b>Errors</b>
///
/// Returns Err([`Error::InvalidInput`
/// ](../error/enum.Error.html#variant.InvalidInput)) if the input does not
/// adhere to the [rules](#pub-fn-backupdb-databaseif---resultstring-error).
///
/// Forwards any errors from [try_from_csv()`
/// ](#trait.ActiveRecord.html#method.try_from_csv).
///
#[macro_export]
macro_rules! define_backup_and_restore {
    ( $( $model:ty ),+ $( , )? ) => {
        pub fn backup(
            db: ::vicocomo::DatabaseIf,
        ) -> Result<Vec<u8>, ::vicocomo::Error> {
            let mut result = ::vicocomo::backup_version().into_bytes();
            result.extend_from_slice(b"\r\n");
        $(  {
                let (table, csv) =
                    <$model as ::vicocomo::ActiveRecord>::try_to_csv(
                        db.clone(),
                        None,
                    )?;
                result.extend_from_slice(
                    (::std::string::String::from("--- ") + &table + " ---\r\n"
                    ).as_bytes()
                );
                result.extend_from_slice(csv.as_bytes());
            }
        )*
            Ok(result)
        }

        pub fn restore(
            db: ::vicocomo::DatabaseIf,
            source: &[u8],
        ) -> Result<(), ::vicocomo::Error> {
            let contents = ::vicocomo::map_error!(
                InvalidInput,
                ::std::str::from_utf8(::vicocomo::check_backup(source)?),
            )?;
            let table_separator =
                ::regex::Regex::new(r#"--- ([0-9A-Za-z_]+) ---\r\n"#)
                    .unwrap();
            if table_separator
                .find(contents)
                .map(|mtch| mtch.start() != 0)
                .unwrap_or(true)
            {
                return Err(::vicocomo::Error::invalid_input(
                    ::vicocomo::texts::get_text(
                        "active-record--restore--invalid-format",
                        &[(
                            "got",
                            &::ljumvall_utils::first_n_chars_ellipsis(
                                contents,
                                50,
                                " ...",
                            )
                        )]
                    )
                ));
            }
            let mut tables = Vec::new();
            let mut table = ("", 0);
            for mtch in table_separator.find_iter(contents) {
                if !table.0.is_empty() {
                    tables.push((table.0, table.1, mtch.start()));
                }
                if mtch.as_str().len() <= 10 {
                    return Err(::vicocomo::Error::invalid_input(
                        "active-record--restore--missing-table-name",
                    ));
                }
                table = (
                    &mtch.as_str()[4..(mtch.as_str().len() - 6)],
                    mtch.end(),
                );
            }
            tables.push((table.0, table.1, contents.len()));
            db.transaction(|db| {
            $(
                {
                    let tnam = <$model as ::vicocomo::ActiveRecord>::table();
                    if let Some(tbl) = tables.iter().find(|t| t.0 == tnam) {
                        <$model as ::vicocomo::ActiveRecord>::try_from_csv(
                            db.clone(),
                            &contents[(tbl.1)..(tbl.2)],
                            None,
                        )?;
                    } else {
                        return Err(::vicocomo::error::Error::invalid_input(
                            ::vicocomo::texts::get_text(
                                "active-record--restore--missing-table",
                                &[("table", &tnam)],
                            ),
                        ));
                    }
                }
            )*
                Ok(())
            })
        }
    };
}

// === Order =================================================================

/// Represents the ordering of the objects returned by
/// [`ActiveRecord::query()`](trait.ActiveRecord.html#tymethod.query).
///
/// The variants are public because you need them to implement
/// `ActiveRecord::query()`.
///
#[derive(Clone, Debug)]
pub enum Order {
    /// The meat of the ORDER clause - no `ORDER BY`!
    ///
    Custom(String),

    /// Use the models default order as defined by the [`vicocomo_order_by`
    /// ](../vicocomo_active_record/index.html) attribute on one or more model
    /// struct fields.
    Dflt,

    /// No `ORDER BY` sent to the database.
    ///
    NoOrder,
}

// === Query =================================================================

/// A reusable query for
/// [`ActiveRecord::query()`](trait.ActiveRecord.html#tymethod.query), see
/// [`QueryBld`](struct.QueryBld.html) for how to build.
///
#[derive(Clone, Debug)]
pub struct Query {
    // The meat of a WHERE clause - no `WHERE`!
    filter: Option<String>,
    // The limit to send to the database.
    limit: Option<usize>,
    // The offset to send to the database.
    offset: Option<usize>,
    // See [`Order`](enum.Order.html).
    order: Order,
    // The values to put in the database query.
    values: Vec<Option<DbValue>>,
}

impl Query { // --------------------------------------------------------------
    /// Create a [query builder](struct.QueryBld.html) to extend `self`.
    ///
    pub fn builder(self) -> QueryBld {
        QueryBld(self, QbState::Valid)
    }

    /// The meat of a WHERE clause - no `WHERE`!
    ///
    pub fn filter(&self) -> Option<&str> {
        self.filter.as_ref().map(|s| s.as_str())
    }

    /// The limit to send to the database.
    ///
    pub fn limit(&self) -> Option<usize> {
        self.limit
    }

    /// The offset to send to the database.
    ///
    pub fn offset(&self) -> Option<usize> {
        self.offset
    }

    /// See [`Order`](enum.Order.html).
    ///
    pub fn order(&self) -> &Order {
        &self.order
    }

    /// Set the limit to use.
    ///
    /// `limit` is the new limit or `None` for no limit.
    ///
    pub fn set_limit<'a>(&'a mut self, limit: Option<usize>) -> &'a mut Self {
        self.limit = limit;
        self
    }

    /// Set the offset to use.
    ///
    /// `offset` is the new offset or `None` for no offset.
    ///
    pub fn set_offset<'a>(&'a mut self, offs: Option<usize>) -> &'a mut Self {
        self.offset = offs;
        self
    }

    /// Set a value to use.
    ///
    /// `ix` is the 1 based index.
    ///
    /// `value` is the value.
    ///
    pub fn set_value<'a>(
        &'a mut self,
        ix: usize,
        value: &DbValue,
    ) -> &'a mut Self {
        self.values[ix - 1] = Some(value.clone());
        self
    }

    /// Set all values to use.
    ///
    /// `values` is a slice with the values.
    ///
    pub fn set_values<'a>(&'a mut self, values: &[DbValue]) -> &'a mut Self {
        self.values = values.iter().map(|v| Some(v.clone())).collect();
        self
    }

    /// The values to put in the database query.
    ///
    pub fn values(&self) -> &[Option<DbValue>] {
        self.values.as_slice()
    }
}

// === QueryBld ==============================================================

/// Builds a [`Query`](struct.Query.html) for [`ActiveRecord::query()`
/// ](trait.ActiveRecord.html#tymethod.query).
///
/// Example:
///
/// ```text
/// let query =
/// QueryBld::new()              // create the query
/// .col("c1")                   // begin building the first WHERE condition
/// .gt(None)                    // the condition is ">", no value (yet)
/// .and("c2")                   // another WHERE clause condition ...
/// .eq(&Some(DbValue::Text("foo"))) // ... but this time a value is given
/// .order("c2 DESC, c1")        // order is just a string w/o "ORDER BY"
/// .limit(4711)                 // setting a limit ...
/// .offset(50)                  // ... and an offset
/// .query().unwrap()            // create the query, cannot be used ...
/// .value(1, &DbValue::Int(17); // ... w/o setting all values (1-based ix)
///                              // Reuse the query with new values:
/// query.set_values(&[DbValue::Int(42), DbValue::Text("bar")]); // No Some()!
/// query.set_limit(Some(4));    // The limit may be changed ...
/// query.set_limit(None);       // ... or removed (the offset, too)
/// ```
///
/// Function sequences that do not make sense, e.g. `new().and()` or
/// `and().`*any function except a relational operator* will make [`query()`
/// ](struct.QueryBld.html#method.query) return None.
///
/// For more complicated WHERE clauses, use the catch-all [`filter()`
/// ](struct.QueryBld.html#method.filter).
///
#[derive(Clone, Debug)]
pub struct QueryBld(Query, QbState);

// --- QueryBld private macros -----------------------------------------------

macro_rules! where_rel_op {
    ($( #[$meta:meta] )* $op_fn:ident, $op_str:literal) => {
        $( #[$meta] )*
        pub fn $op_fn(mut self, value: Option<&DbValue>) -> Self {
            match self.1 {
                QbState::GotCol => {
                    self.0.filter.as_mut().unwrap().push_str(&format!(
                        concat!(" ", $op_str, " ${}"),
                        self.0.values.len() + 1,
                    ));
                    self.0.values.push(value.map(|v| v.clone()));
                    self.1 = QbState::Valid;
                    self
                },
                _ => self.invalidate(),
            }
        }
    };
}

macro_rules! where_log_op {
    ($( #[$meta:meta] )* $op_fn:ident, $op_str:literal) => {
        $( #[$meta] )*
        #[allow(unused_mut)]
        pub fn $op_fn(mut self, db_col: &str) -> Self {
            match self.1 {
                QbState::Valid if self.0.filter.is_some() => {
                    self.0.filter.as_mut().unwrap().push_str(
                        concat!(" ", $op_str, " ")
                    );
                    self.0.filter.as_mut().unwrap().push_str(db_col);
                    self.1 = QbState::GotCol;
                    self
                },
                _ => self.invalidate(),
            }
        }
    };
}

impl QueryBld { // -----------------------------------------------------------

    // public methods w/o receiver - - - - - - - - - - - - - - - - - - - - - -

    /// Create a query builder.
    ///
    pub fn new() -> Self {
        Self(
            Query {
                filter: None,
                limit: None,
                offset: None,
                order: Order::Dflt,
                values: Vec::new(),
            },
            QbState::Valid,
        )
    }

    // public methods with receiver  - - - - - - - - - - - - - - - - - - - - -

    where_log_op! {
        /// Initiate building another WHERE condition AND-ed to the previous.
        ///
        /// `db_col` is the column name in the database.
        ///
        and, "AND"
    }

    /// Initiate building the first WHERE condition.
    ///
    /// `db_col` is the column name in the database.
    ///
    pub fn col(mut self, db_col: &str) -> Self {
        match self.1 {
            QbState::Valid if self.0.filter.is_none() => {
                self.0.filter = Some(db_col.to_string());
                self.1 = QbState::GotCol;
                self
            }
            _ => self.invalidate(),
        }
    }

    where_rel_op! {
    /// Complete building a WHERE condition.
    ///
    /// `value` is the value to use or `None` for a reusable [`Query`
    /// ](struct.Query.html).
    ///
        eq, "="
    }

    /// Add a WHERE condition.
    ///
    /// `fltr` is the meat of a WHERE clause - no `WHERE`!  It may be
    /// parameterized using the notation `$`*n* for the n:th parameter, 1
    /// based.
    ///
    /// If there is an existing WHERE clause, *n* in the `$`*n* in the new one
    /// are increased with the number of previously existing parameters and
    /// the new clause will be `"(`*old clause*`) AND `*new condition*`"`.
    ///
    /// `values` are the new parameter values, appended to any existing.
    ///
    pub fn filter(mut self, fltr: &str, values: &[Option<DbValue>]) -> Self {
        match self.1 {
            QbState::Valid => {
                self.0.filter = Some(match self.0.filter {
                    Some(old_filter) => {
                        // add old parameter count to new parameter indexes
                        use std::sync::OnceLock;
                        static PARAMS: OnceLock<Regex> = OnceLock::new();
                        let old_par_count = self.0.values.len();
                        let mut new_filter = String::new();
                        let mut last = 0;
                        for cap in PARAMS
                            .get_or_init(|| {
                                Regex::new(r"\$([0-9]+)").unwrap()
                            })
                            .captures_iter(fltr)
                        {
                            let nr = cap.get(1).unwrap();
                            new_filter.extend(fltr[last..nr.start()].chars());
                            new_filter +=
                                &(nr.as_str().parse::<usize>().unwrap()
                                    + old_par_count)
                                    .to_string();
                            last = nr.end();
                        }
                        if last < fltr.len() {
                            new_filter.extend(fltr[last..].chars());
                        }
                        format!("({}) AND {}", old_filter, &new_filter)
                    }
                    None => fltr.to_string(),
                });
                self.0.values.extend(values.iter().map(|v| v.clone()));
                self
            }
            _ => self.invalidate(),
        }
    }

    where_rel_op! {
        /// Complete building a WHERE condition.
        ///
        /// `value` is the value to use or `None` for a reusable [`Query`
        /// ](struct.Query.html).
        ///
        ge, ">="
    }

    where_rel_op! {
        /// Complete building a WHERE condition.
        ///
        /// `value` is the value to use or `None` for a reusable [`Query`
        /// ](struct.Query.html).
        ///
        gt, ">"
    }

    where_rel_op! {
        /// Complete building a WHERE condition.
        ///
        /// `value` is the value to use or `None` for a reusable [`Query`
        /// ](struct.Query.html).
        ///
        le, "<="
    }

    /// Set a limit on the number of returned objects.
    ///
    /// `limit` is the limit to use.
    ///
    pub fn limit(mut self, limit: usize) -> Self {
        self.0.limit = Some(limit);
        self
    }

    where_rel_op! {
        /// Complete building a WHERE condition.
        ///
        /// `value` is the value to use or `None` for a reusable [`Query`
        /// ](struct.Query.html).
        ///
        lt, "<"
    }

    where_rel_op! {
        /// Complete building a WHERE condition.
        ///
        /// `value` is the value to use or `None` for a reusable [`Query`
        /// ](struct.Query.html).
        ///
        ne, "<>"
    }

    /// Remove the ORDER clause, e.g. to avoid default ordering.
    ///
    pub fn no_order(mut self) -> Self {
        self.0.order = Order::NoOrder;
        self
    }

    /// Set the number of objects to skip.
    ///
    /// `offset` is the offset to use.
    ///
    pub fn offset(mut self, offset: usize) -> Self {
        self.0.offset = Some(offset);
        self
    }

    where_log_op! {
        /// Initiate building another WHERE condition OR-ed to the previous.
        ///
        /// `db_col` is the column name in the database.
        ///
        or, "OR"
    }

    /// Define an ORDER clause.
    ///
    /// `order` is the meat of the ORDER clause - no `ORDER BY`!
    ///
    pub fn order(mut self, order: &str) -> Self {
        self.0.order = Order::Custom(order.to_string());
        self
    }

    /// Freeze the query by returning the built
    /// [`Query`](struct.Query.html) struct.
    ///
    /// `None` is returned if there were problems building the query.
    ///
    pub fn query(self) -> Option<Query> {
        match self.1 {
            QbState::Valid => Some(self.0),
            _ => {
                self.invalidate();
                None
            }
        }
    }

    // private - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    fn invalidate(mut self) -> Self {
        self.1 = QbState::Invalid;
        self
    }
}

// === functions =============================================================

/// A backup version string produced from [`BACKUP_VERSION`
/// ](const.BACKUP_VERSION.html).
///
pub fn backup_version() -> String {
    format!(
        "--- vicocomo backup format version {}.{} ---",
        BACKUP_VERSION.0, BACKUP_VERSION.1,
    )
}

/// Check that `source` appears to be a backup generated by [`backup()`
/// ](../macro.define_backup_and_restore.html) with a version that can be
/// understood by [`restore()`](../macro.define_backup_and_restore.html)
///
/// Returns the part of `source` after the version string if this is indeed
/// the case.
///
/// <b>Errors</b>
///
/// Returns Err([`Error::InvalidInput`
/// ](../error/enum.Error.html#variant.InvalidInput)) if the input does not
/// start with `"--- vicocomo backup format version 0.6 ---\r\n"`.
///
pub fn check_backup(source: &[u8]) -> Result<&[u8], Error> {
    regex::bytes::Regex::new(&format!("^{}\\r\\n", backup_version()))
        .unwrap()
        .find(source)
        .map(|mtch| &source[mtch.end()..])
        .ok_or_else(|| {
            Error::invalid_input(&String::from_utf8_lossy(
                &source[..(min(source.len(), 50))],
            ))
        })
}

// === private ===============================================================

#[derive(Clone, Debug)]
enum QbState {
    Valid,
    GotCol,
    Invalid,
}
